
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>UQpy.SampleMethods &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for UQpy.SampleMethods</h1><div class="highlight"><pre>
<span></span><span class="c1"># UQpy is distributed under the MIT license.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018  -- Michael D. Shields</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the</span>
<span class="c1"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="c1"># persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of the</span>
<span class="c1"># Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="c1"># COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="c1"># OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;This module contains functionality for all the sampling methods supported in UQpy.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">sys</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Monte Carlo Simulation</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS">[docs]</a><span class="k">class</span> <span class="nc">MCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>

<span class="sd">            Perform Monte Carlo sampling (MCS) of independent random variables from a user-specified probability</span>
<span class="sd">            distribution using inverse transform method.</span>

<span class="sd">        Input:</span>
<span class="sd">            :param dist_name: A string or string list containing the names of the distributions of the random variables.</span>
<span class="sd">            Distribution names must match those in the Distributions module.</span>
<span class="sd">            If the distribution does not match one from the Distributions module, the user must provide a custom</span>
<span class="sd">            distribution file with name dist_name.py. See documentation for the Distributions module. The length of the</span>
<span class="sd">            list must equal the dimension of the random vector.</span>
<span class="sd">            :type dist_name: string or string list</span>

<span class="sd">            :param dist_params: Parameters of the distribution.</span>
<span class="sd">            Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">            Each item in the list, dist_params[i], specifies the parameters for the corresponding distribution,</span>
<span class="sd">            dist_name[i]. Relevant parameters for each distribution can be found in the documentation for the</span>
<span class="sd">            Distributions module.</span>
<span class="sd">            :type dist_params: ndarray or list</span>

<span class="sd">            :param nsamples: Number of samples to generate.</span>
<span class="sd">            No Default Value: nsamples must be prescribed.</span>
<span class="sd">            :type nsamples: int</span>

<span class="sd">            :param var_names: names of variables</span>
<span class="sd">            :type var_names: list of strings</span>

<span class="sd">            :param verbose: A boolean declaring whether to write text to the terminal.</span>
<span class="sd">            :type verbose: bool</span>

<span class="sd">        Output:</span>
<span class="sd">            :return: MCS.samples: Set of generated samples</span>
<span class="sd">            :rtype: MCS.samples: ndarray of dimension (nsamples, ndim)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Dimitris G.Giovanis</span>
    <span class="c1"># Last Modified: 11/12/2018 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: nsamples must be defined.&#39;</span><span class="p">)</span>
        <span class="c1"># No need to do other checks as they will be done within Distributions.py</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">var_names</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Monte Carlo Sampling...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Monte Carlo Sampling Complete.&#39;</span><span class="p">)</span>

        <span class="c1"># Shape the array as (1,n) if nsamples=1, and (n,1) if nsamples=n</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Latin hypercube sampling  (LHS)</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="LHS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS">[docs]</a><span class="k">class</span> <span class="nc">LHS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>

<span class="sd">            A class that creates a Latin Hypercube Design for experiments. Samples on hypercube [0, 1]^n  and on the</span>
<span class="sd">            parameter space are generated.</span>

<span class="sd">        Input:</span>
<span class="sd">            :param dimension: A scalar value defining the dimension of the random variables.</span>
<span class="sd">                              If dimension is not provided then dimension is equal to the length of the dist_name.</span>
<span class="sd">            :type dimension: int</span>

<span class="sd">            :param dist_name: A list containing the names of the distributions of the random variables.</span>
<span class="sd">                              Distribution names must match those in the Distributions module.</span>
<span class="sd">                              If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                              provide custom_dist.py.</span>
<span class="sd">                              The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                              dimension.</span>
<span class="sd">            :type dist_name: string list</span>

<span class="sd">            :param dist_params: Parameters of the distribution.</span>
<span class="sd">                                Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                                Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                                distribution, dist[i].</span>
<span class="sd">            :type dist_params: list</span>

<span class="sd">            param: distribution: An object list containing the distributions of the random variables.</span>
<span class="sd">                                 Each item in the list is an object of the Distribution class (see Distributions.py).</span>
<span class="sd">                                 The list has length equal to dimension.</span>
<span class="sd">            :type distribution: list</span>

<span class="sd">            :param lhs_criterion: The criterion for generating sample points</span>
<span class="sd">                                  Options:</span>
<span class="sd">                                        1. &#39;random&#39; - completely random \n</span>
<span class="sd">                                        2. &#39;centered&#39; - points only at the centre \n</span>
<span class="sd">                                        3. &#39;maximin&#39; - maximising the minimum distance between points \n</span>
<span class="sd">                                        4. &#39;correlate&#39; - minimizing the correlation between the points \n</span>
<span class="sd">                                  Default: &#39;random&#39;</span>
<span class="sd">            :type lhs_criterion: str</span>

<span class="sd">            :param lhs_metric: The distance metric to use. Supported metrics are:</span>
<span class="sd">                               &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;, &#39;correlation&#39;, &#39;cosine&#39;, &#39;dice&#39;,</span>
<span class="sd">                               &#39;euclidean&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulsinski&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;,</span>
<span class="sd">                               &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;,</span>
<span class="sd">                               &#39;sqeuclidean&#39;, &#39;yule&#39;.</span>
<span class="sd">                                Default: &#39;euclidean&#39;.</span>
<span class="sd">            :type lhs_metric: str</span>

<span class="sd">            :param lhs_iter: The number of iteration to run. Required only for maximin, correlate and criterion.</span>
<span class="sd">                             Default: 100</span>
<span class="sd">            :type lhs_iter: int</span>

<span class="sd">            :param nsamples: Number of samples to generate.</span>
<span class="sd">                             No Default Value: nsamples must be prescribed.</span>
<span class="sd">            :type nsamples: int</span>

<span class="sd">        Output:</span>
<span class="sd">            :return: LHS.samples: Set of LHS samples</span>
<span class="sd">            :rtype: LHS.samples: ndarray</span>

<span class="sd">            :return: LHS.samplesU01: Set of uniform LHS samples on [0, 1]^dimension.</span>
<span class="sd">            :rtype: LHS.samplesU01: ndarray.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Created by: Lohit Vandanapu</span>
    <span class="c1"># Last modified: 6/20/2018 by Dimitris G. Giovanis</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lhs_criterion</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="n">lhs_metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
                 <span class="n">lhs_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">var_names</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="o">=</span> <span class="n">lhs_criterion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs_metric</span> <span class="o">=</span> <span class="n">lhs_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span> <span class="o">=</span> <span class="n">lhs_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_lhs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">var_names</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_lhs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">samples_u_to_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
            <span class="n">samples_u_to_x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Successful execution of LHS design..&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">samples_u_to_x</span>

    <span class="k">def</span> <span class="nf">_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="o">==</span> <span class="s1">&#39;centered&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="o">==</span> <span class="s1">&#39;maximin&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="o">==</span> <span class="s1">&#39;correlate&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span> <span class="nf">_centered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span> <span class="nf">_max_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>

        <span class="n">max_min_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span><span class="p">):</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">samples_try</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_metric</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_min_dist</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">max_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Achieved max_min distance of &#39;</span><span class="p">,</span> <span class="n">max_min_dist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span> <span class="nf">_correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>

        <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span><span class="p">):</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples_try</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_corr</span><span class="p">:</span>
                <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Achieved minimum correlation of &#39;</span><span class="p">,</span> <span class="n">min_corr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span>

    <span class="c1">################################################################################################################</span>
    <span class="c1"># Latin hypercube checks.</span>
    <span class="c1"># Necessary parameters:  1. Probability distribution, 2. Probability distribution parameters</span>
    <span class="c1"># Optional: number of samples (default 100), criterion, metric, iterations</span>

    <span class="k">def</span> <span class="nf">init_lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Ensure that the number of samples is defined</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Number of samples not defined.&quot;</span><span class="p">)</span>

        <span class="c1"># Check the dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span>

        <span class="c1"># Ensure that distribution parameters are assigned</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Distribution parameters not defined.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_params</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of dist_params list should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Check for dimensional consistency</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">,</span> <span class="s1">&#39;maximin&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported lhs criteria: &#39;random&#39;, &#39;centered&#39;, &#39;maximin&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;correlate&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lhs_metric</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span> <span class="s1">&#39;canberra&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;dice&#39;</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;kulsinski&#39;</span><span class="p">,</span> <span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;matching&#39;</span><span class="p">,</span> <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span> <span class="s1">&#39;russellrao&#39;</span><span class="p">,</span> <span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span> <span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span> <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported lhs distances: &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;cityblock&#39;,&quot;</span>
                                          <span class="s2">&quot; &#39;correlation&#39;, &#39;cosine&#39;,&#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;kulsinski&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;,&quot;</span>
                                          <span class="s2">&quot;&#39;russellrao&#39;, &#39;seuclidean&#39;,&#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs_iter</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Stratified Sampling  (STS)</span>
<span class="c1">########################################################################################################################</span>
<span class="k">class</span> <span class="nc">STS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>

<span class="sd">            Generate samples from an assigned probability density function using Stratified Sampling.</span>

<span class="sd">            References:</span>
<span class="sd">            M.D. Shields, K. Teferra, A. Hapij, and R.P. Daddazio, &quot;Refined Stratified Sampling for efficient Monte</span>
<span class="sd">            Carlo based uncertainty quantification,&quot; Reliability Engineering and System Safety,vol.142, pp.310-325,2015.</span>

<span class="sd">        Input:</span>
<span class="sd">            :param dimension: A scalar value defining the dimension of target density function.</span>
<span class="sd">                              Default: Length of sts_design.</span>
<span class="sd">            :type dimension: int</span>

<span class="sd">            :param dist_name: A list containing the names of the distributions of the random variables.</span>
<span class="sd">                              Distribution names must match those in the Distributions module.</span>
<span class="sd">                              If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                              provide custom_dist.py.</span>
<span class="sd">                              The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                              dimension.</span>
<span class="sd">            :type dist_name: string list</span>

<span class="sd">            :param dist_params: Parameters of the distribution</span>
<span class="sd">                                Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                                Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                                distribution, dist[i].</span>
<span class="sd">            :type dist_params: list</span>

<span class="sd">            param: distribution: An object list containing the distributions of the random variables.</span>
<span class="sd">                                 Each item in the list is an object of the Distribution class (see Distributions.py).</span>
<span class="sd">                                 The list has length equal to dimension.</span>
<span class="sd">            :type distribution: list</span>

<span class="sd">            :param sts_design: Specifies the number of strata in each dimension</span>
<span class="sd">            :type sts_design: int list</span>

<span class="sd">            :param input_file: File path to input file specifying stratum origins and stratum widths.</span>
<span class="sd">                               Default: None.</span>
<span class="sd">            :type input_file: string</span>

<span class="sd">        Output:</span>
<span class="sd">            :return: STS.samples: Set of stratified samples.</span>
<span class="sd">            :rtype: STS.samples: ndarray</span>

<span class="sd">            :return: STS.samplesU01: Set of uniform stratified samples on [0, 1]^dimension</span>
<span class="sd">            :rtype: STS.samplesU01: ndarray</span>

<span class="sd">            :return: STS.strata: Instance of the class SampleMethods.Strata</span>
<span class="sd">            :rtype: STS.strata: ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Michael Shields</span>
    <span class="c1"># Last modified: 6/7/2018 by Dimitris Giovanis &amp; Michael Shields</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sts_design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sts_criterion</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="o">=</span> <span class="n">sts_design</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">=</span> <span class="n">sts_criterion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sts</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_sts</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span>

    <span class="k">def</span> <span class="nf">run_sts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">samples_u_to_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                                      <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;centered&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>

            <span class="n">samples_u_to_x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Successful execution of STS design..&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">samples_u_to_x</span>

    <span class="k">def</span> <span class="nf">init_sts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Check for dimensional consistency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Dimension must be specified.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_name</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of i_cdf should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_params</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of dist_params list should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure that distribution parameters are assigned</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Distribution parameters not defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Stratum design is not defined.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">Strata</span><span class="p">(</span><span class="n">input_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;sts_design&#39;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">Strata</span><span class="p">(</span><span class="n">n_strata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span>

        <span class="c1"># Check sampling criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported sts criteria: &#39;random&#39;, &#39;centered&#39;&quot;</span><span class="p">)</span>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Strata</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">Strata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>

<span class="sd">            Define a rectilinear stratification of the n-dimensional unit hypercube [0, 1]^dimension with N strata.</span>

<span class="sd">        Input:</span>
<span class="sd">            :param n_strata: A list of dimension n defining the number of strata in each of the n dimensions</span>
<span class="sd">                            Creates an equal stratification with strata widths equal to 1/n_strata</span>
<span class="sd">                            The total number of strata, N, is the product of the terms of n_strata</span>
<span class="sd">                            Example -</span>
<span class="sd">                            n_strata = [2, 3, 2] creates a 3d stratification with:</span>
<span class="sd">                            2 strata in dimension 0 with stratum widths 1/2</span>
<span class="sd">                            3 strata in dimension 1 with stratum widths 1/3</span>
<span class="sd">                            2 strata in dimension 2 with stratum widths 1/2</span>
<span class="sd">            :type n_strata int list</span>

<span class="sd">            :param input_file: File path to input file specifying stratum origins and stratum widths.</span>
<span class="sd">                               Default: None</span>
<span class="sd">            :type input_file: string</span>

<span class="sd">        Output:</span>
<span class="sd">            :return origins: An array of dimension N x n specifying the origins of all strata</span>
<span class="sd">                            The origins of the strata are the coordinates of the stratum orthotope nearest the global</span>
<span class="sd">                            origin.</span>
<span class="sd">                            Example - A 2D stratification with 2 strata in each dimension</span>
<span class="sd">                            origins = [[0, 0]</span>
<span class="sd">                                      [0, 0.5]</span>
<span class="sd">                                      [0.5, 0]</span>
<span class="sd">                                      [0.5, 0.5]]</span>
<span class="sd">            :rtype origins: array</span>

<span class="sd">            :return widths: An array of dimension N x n specifying the widths of all strata in each dimension</span>
<span class="sd">                           Example - A 2D stratification with 2 strata in each dimension</span>
<span class="sd">                           widths = [[0.5, 0.5]</span>
<span class="sd">                                     [0.5, 0.5]</span>
<span class="sd">                                     [0.5, 0.5]</span>
<span class="sd">                                     [0.5, 0.5]]</span>
<span class="sd">            :rtype widths: ndarray</span>

<span class="sd">            :return weights: An array of dimension 1 x N containing sample weights.</span>
<span class="sd">                            Sample weights are equal to the product of the strata widths (i.e. they are equal to the</span>
<span class="sd">                            size of the strata in the [0, 1]^n space.</span>
<span class="sd">            :rtype weights: ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span> <span class="o">=</span> <span class="n">n_strata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">origins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span>

        <span class="c1"># Read a stratified design from an input file.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The strata are not fully defined. Must provide [n_strata], &#39;</span>
                             <span class="s1">&#39;input file, or [origins] and [widths].&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Read the strata from the specified input file</span>
                <span class="c1"># See documentation for input file formatting</span>
                <span class="n">array_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>

                <span class="c1"># Check to see that the strata are space-filling</span>
                <span class="n">space_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The stratum design is not space-filling.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The stratum design is over-filling.&#39;</span><span class="p">)</span>

        <span class="c1"># Define a rectilinear stratification by specifying the number of strata in each dimension via nstrata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullfact</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fullfact</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Description:</span>

<span class="sd">                Create a full-factorial design</span>

<span class="sd">                Note: This function has been modified from pyDOE, released under BSD License (3-Clause)</span>
<span class="sd">                Copyright (C) 2012 - 2013 - Michael Baudin</span>
<span class="sd">                Copyright (C) 2012 - Maria Christopoulou</span>
<span class="sd">                Copyright (C) 2010 - 2011 - INRIA - Michael Baudin</span>
<span class="sd">                Copyright (C) 2009 - Yann Collette</span>
<span class="sd">                Copyright (C) 2009 - CEA - Jean-Marc Martinez</span>
<span class="sd">                Original source code can be found at:</span>
<span class="sd">                https://pythonhosted.org/pyDOE/#</span>
<span class="sd">                or</span>
<span class="sd">                https://pypi.org/project/pyDOE/</span>
<span class="sd">                or</span>
<span class="sd">                https://github.com/tisimst/pyDOE/</span>

<span class="sd">            Input:</span>
<span class="sd">                :param levels: A list of integers that indicate the number of levels of each input design factor.</span>
<span class="sd">                :type levels: list</span>

<span class="sd">            Output:</span>
<span class="sd">                :return ff: Full-factorial design matrix.</span>
<span class="sd">                :rtype ff: ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Number of factors</span>
        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="c1"># Number of combinations</span>
        <span class="n">n_comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_comb</span><span class="p">,</span> <span class="n">n_factors</span><span class="p">))</span>

        <span class="n">level_repeat</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">range_repeat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_factors</span><span class="p">):</span>
            <span class="n">range_repeat</span> <span class="o">//=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lvl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lvl</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">level_repeat</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">lvl</span> <span class="o">*</span> <span class="n">range_repeat</span>
            <span class="n">level_repeat</span> <span class="o">*=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ff</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span>

        <span class="k">return</span> <span class="n">ff</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Refined Stratified Sampling (RSS)</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">RSS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Description:</span>

<span class="sd">            Generate new samples using adaptive sampling methods, i.e. Refined Stratified Sampling and Gradient</span>
<span class="sd">            Enhanced Refined Stratified Sampling.</span>

<span class="sd">            References:</span>
<span class="sd">            Michael D. Shields, Kirubel Teferra, Adam Hapij and Raymond P. Daddazio, &quot;Refined Stratified Sampling for</span>
<span class="sd">                efficient Monte Carlo based uncertainty quantification&quot;, Reliability Engineering &amp; System Safety,</span>
<span class="sd">                ISSN: 0951-8320, Vol: 142, Page: 310-325, 2015.</span>

<span class="sd">            M. D. Shields, &quot;Adaptive Monte Carlo analysis for strongly nonlinear stochastic systems&quot;,</span>
<span class="sd">                Reliability Engineering &amp; System Safety, ISSN: 0951-8320, Vol: 175, Page: 207-224, 2018.</span>
<span class="sd">        Input:</span>
<span class="sd">            :param x: A class object, it should be generated using STS or RSS class.</span>
<span class="sd">            :type x: class</span>

<span class="sd">            :param model: Python model which is used to evaluate the function value</span>
<span class="sd">            :type model: str</span>

<span class="sd">            :param meta: A string specifying the method used to estimate the gradient.</span>
<span class="sd">                         Options: Delaunay, Kriging</span>
<span class="sd">            :type meta: str</span>

<span class="sd">            :param cell: A string specifying the stratification of sample domain.</span>
<span class="sd">                         Options: Rectangular and Voronoi</span>
<span class="sd">            :type cell: str</span>

<span class="sd">            :param nsamples: Final size of the samples.</span>
<span class="sd">            :type nsamples: int</span>

<span class="sd">            :param min_train_size: Minimum size of training data around new sample used to update surrogate.</span>
<span class="sd">                                   Default: nsamples</span>
<span class="sd">            :type min_train_size: int</span>

<span class="sd">            :param step_size: Step size to calculate the gradient using central difference. Only required if Delaunay is</span>
<span class="sd">                              used as surrogate approximation.</span>
<span class="sd">            :type step_size: float</span>

<span class="sd">            :param reg_model: Regression model used to estimate gradient by using kriging surrogate. Only required</span>
<span class="sd">                               if kriging is used as surrogate approximation.</span>
<span class="sd">            :type reg_model: str</span>

<span class="sd">            :param corr_model: Correlation model used to estimate gradient by using kriging surrogate. Only required</span>
<span class="sd">                               if kriging is used as surrogate approximation.</span>
<span class="sd">            :type corr_model: str</span>

<span class="sd">            :param corr_model_params: Correlation model parameters used to estimate hyperparamters for kriging</span>
<span class="sd">                                      surrogate.</span>
<span class="sd">            :type corr_model_params: ndarray</span>

<span class="sd">            :param n_opt: Number of times optimization problem is to be solved with different starting point.</span>
<span class="sd">                          Default: 1</span>
<span class="sd">            :type n_opt: int</span>

<span class="sd">        Output:</span>
<span class="sd">            :return: RSS.samples: Final/expanded samples.</span>
<span class="sd">            :rtype: RSS.samples: ndarray</span>

<span class="sd">            :return: RSS.values: Function value evaluated at the expanded samples.</span>
<span class="sd">            :rtype: RSS.values: ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Mohit S. Chauhan</span>
    <span class="c1"># Last modified: 12/03/2018 by Mohit S. Chauhan</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="s1">&#39;Delaunay&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="s1">&#39;Rectangular&#39;</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">min_train_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">reg_model</span><span class="o">=</span><span class="s1">&#39;Quadratic&#39;</span><span class="p">,</span>
                 <span class="n">corr_model_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">=</span> <span class="s1">&#39;Refined&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">meta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span> <span class="o">=</span> <span class="n">min_train_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span> <span class="o">=</span> <span class="n">corr_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">corr_model_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span> <span class="o">=</span> <span class="n">reg_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_opt</span> <span class="o">=</span> <span class="n">n_opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_rss</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">samplesU01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">strata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_rss</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">UQpy.RunModel</span> <span class="k">import</span> <span class="n">RunModel</span>
        <span class="kn">from</span> <span class="nn">UQpy.Surrogates</span> <span class="k">import</span> <span class="n">Krig</span>
        <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>
        <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">LinearNDInterpolator</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span>
        <span class="kn">import</span> <span class="nn">numpy.matlib</span> <span class="k">as</span> <span class="nn">matlib</span>
        <span class="kn">import</span> <span class="nn">itertools</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing RSS design...&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">cent_diff</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
            <span class="n">dydx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">dirr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">temp</span><span class="p">[:,</span> <span class="n">dirr</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">temp</span>
                <span class="n">dydx</span><span class="p">[:,</span> <span class="n">dirr</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">f</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">low</span><span class="p">))</span> <span class="o">/</span> <span class="n">h</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">dydx</span>

        <span class="k">def</span> <span class="nf">surrogate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">corr_m_p</span><span class="p">,</span> <span class="n">reg_m</span><span class="p">,</span> <span class="n">corr_m</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">==</span> <span class="s1">&#39;Delaunay&#39;</span><span class="p">:</span>
                <span class="n">tck</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">cent_diff</span><span class="p">(</span><span class="n">tck</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">==</span> <span class="s1">&#39;Kriging&#39;</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                    <span class="n">tck</span> <span class="o">=</span> <span class="n">Krig</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">reg_model</span><span class="o">=</span><span class="n">reg_m</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="n">corr_m</span><span class="p">,</span> <span class="n">corr_model_params</span><span class="o">=</span><span class="n">corr_m_p</span><span class="p">,</span>
                               <span class="n">n_opt</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
                <span class="n">corr_m_p</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">corr_model_params</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">cent_diff</span><span class="p">(</span><span class="n">tck</span><span class="o">.</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
                <span class="c1"># gr = tck.jacobian(xt)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">==</span> <span class="s1">&#39;Kriging_Sklearn&#39;</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">corr_m</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">gr</span> <span class="o">=</span> <span class="n">cent_diff</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Does not identify &#39;meta&#39;.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gr</span><span class="p">,</span> <span class="n">corr_m_p</span>

        <span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mts</span><span class="p">,</span> <span class="n">max_dim</span><span class="p">):</span>
            <span class="c1"># Identify the indices of &#39;mts&#39; number of points in array &#39;x&#39;, which are closest to point &#39;pt&#39;.</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="mf">0.2</span>
            <span class="n">train</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">train</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mts</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="n">pt</span> <span class="o">-</span> <span class="n">ff</span> <span class="o">*</span> <span class="n">max_dim</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="n">pt</span> <span class="o">+</span> <span class="n">ff</span> <span class="o">*</span> <span class="n">max_dim</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">x_ind</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>
                <span class="n">train</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">x_ind</span><span class="p">[</span><span class="n">k_</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                        <span class="n">train</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span>
                <span class="n">ff</span> <span class="o">=</span> <span class="n">ff</span> <span class="o">+</span> <span class="mf">0.1</span>
            <span class="k">return</span> <span class="n">train</span>

        <span class="n">values</span><span class="p">,</span> <span class="n">dydx1</span><span class="p">,</span> <span class="n">tri</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">dimension</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">lst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">])</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">==</span> <span class="s1">&#39;Delaunay&#39;</span><span class="p">:</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">dimension</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">lst</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Gradient&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">RunModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">model_script</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                <span class="n">dydx1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_opt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">simplex</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="s1">&#39;simplices&#39;</span><span class="p">)</span>
                <span class="n">dydx1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">n_opt</span><span class="p">)</span>

        <span class="n">initial_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                <span class="c1"># Determine the stratum to break</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Gradient&#39;</span><span class="p">:</span>
                    <span class="c1"># Estimate the variance within each stratum by assuming a uniform distribution over the stratum.</span>
                    <span class="c1"># All input variables are independent</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="c1"># Estimate the variance over the stratum by Delta Method</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dydx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dydx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span>
                    <span class="n">bin2break</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))]</span>

                <span class="c1"># Determine the largest dimension of the stratum and define this as the cut direction</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Refined&#39;</span><span class="p">:</span>
                    <span class="c1"># Cut the stratum in a random direction</span>
                    <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">dir2break</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Cut the stratum in the direction of maximum gradient</span>
                    <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">))</span>
                    <span class="n">dir2break</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dydx1</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">t</span><span class="p">]))]</span>

                <span class="c1"># Divide the stratum bin2break in the direction dir2break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="p">:]])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="p">:]])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span>
                        <span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">])</span>

                <span class="c1"># Add an uniform random sample inside new stratum</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="c1"># Adding new sample to points, samplesU01 and samples attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
                    <span class="n">icdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                    <span class="n">new</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">icdf</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
                <span class="n">simplex</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="s1">&#39;simplices&#39;</span><span class="p">)</span>
                <span class="c1"># Estimate the variance over the stratum by Delta Method</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dimension</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">0</span><span class="p">))):</span>
                    <span class="c1"># Define Simplex</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]]</span>
                    <span class="c1"># Estimate the volume of simplex</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">sim</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">simplex</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Gradient&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                            <span class="c1"># Estimate standard deviation of points</span>
                            <span class="kn">from</span> <span class="nn">statistics</span> <span class="k">import</span> <span class="n">stdev</span>
                            <span class="n">std</span> <span class="o">=</span> <span class="n">stdev</span><span class="p">(</span><span class="n">sim</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                            <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                                    <span class="n">dimension</span> <span class="o">*</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dydx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dydx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Refined&#39;</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">weights</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">weights</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
                    <span class="n">bin2add</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">))]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

                <span class="c1"># Creating sub-simplex</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">[</span><span class="n">bin2add</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="n">col_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dimension</span><span class="p">)))</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>    <span class="c1"># node: an array containing mid-point of edges</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">node</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">col_one</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">dimension</span>

                <span class="c1"># Using Simplex class to generate new sample</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>
                <span class="c1"># Adding new sample to points, samplesU01 and samples attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
                    <span class="n">icdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                    <span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">icdf</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>
                <span class="c1"># Creating Delaunay triangulation from the new points</span>
                <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Does not identify &#39;cell&#39;.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Gradient&#39;</span><span class="p">:</span>

                <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                    <span class="n">y_new</span> <span class="o">=</span> <span class="n">RunModel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">model_script</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">qoi_list</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">values</span><span class="p">,</span> <span class="n">y_new</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span><span class="p">:</span>
                    <span class="c1"># Global surrogate updating: Update the surrogate model using all the points</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                        <span class="n">in_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">in_update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">simplex</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="s1">&#39;simplices&#39;</span><span class="p">)</span>
                        <span class="n">in_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">in_update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">simplex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Local surrogate updating: Update the surrogate model using min_train_size</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">==</span> <span class="s1">&#39;Delaunay&#39;</span><span class="p">:</span>
                            <span class="n">in_train</span> <span class="o">=</span> <span class="n">local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span><span class="p">,</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">in_train</span> <span class="o">=</span> <span class="n">local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span><span class="p">,</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">))</span>
                        <span class="n">in_update</span> <span class="o">=</span> <span class="n">local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">simplex</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="s1">&#39;simplices&#39;</span><span class="p">)</span>
                        <span class="c1"># in_train: Indices of samples used to update surrogate approximation</span>
                        <span class="n">in_train</span> <span class="o">=</span> <span class="n">local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span><span class="p">,</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">)))</span>
                        <span class="c1"># in_update: Indices of centroid of simplex, where gradient is updated</span>
                        <span class="n">in_update</span> <span class="o">=</span> <span class="n">local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">)))</span>

                <span class="c1"># Update the surrogate model &amp; the store the updated gradients</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                    <span class="n">dydx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dydx1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimension</span><span class="p">)])</span>
                    <span class="n">dydx1</span><span class="p">[</span><span class="n">in_update</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">in_train</span><span class="p">,</span> <span class="p">:],</span>
                                                                            <span class="n">values</span><span class="p">[</span><span class="n">in_train</span><span class="p">,</span> <span class="p">:],</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">in_update</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span>
                                                                            <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">in_update</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">simplex</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="s1">&#39;simplices&#39;</span><span class="p">)</span>
                    <span class="n">dydx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dydx1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">simplex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dydx1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dimension</span><span class="p">])])</span>
                    <span class="n">dydx1</span><span class="p">[</span><span class="n">in_update</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">surrogate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">in_train</span><span class="p">,</span> <span class="p">:],</span>
                                                                            <span class="n">values</span><span class="p">[</span><span class="n">in_train</span><span class="p">,</span> <span class="p">:],</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span>
                                                                            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">points</span><span class="p">[</span>
                                                                                        <span class="n">simplex</span><span class="p">[</span><span class="n">in_update</span><span class="p">,</span> <span class="p">:]],</span>
                                                                                    <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">==</span> <span class="s1">&#39;Gradient&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">!=</span> <span class="s1">&#39;Delaunay&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="n">dimension</span><span class="p">:,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">init_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;STS&#39;</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: x should be a class object from STS or RSS class.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">=</span> <span class="s1">&#39;Gradient&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="s1">&#39;Delaunay&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Delaunay&#39;</span><span class="p">,</span> <span class="s1">&#39;Kriging&#39;</span><span class="p">,</span> <span class="s1">&#39;Kriging_Sklearn&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Input &#39;meta&#39; is not specified correctly.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="s1">&#39;Rectangular&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Rectangular&#39;</span><span class="p">,</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Input &#39;cell&#39; is not specified correctly.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: nsamples should be integer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Already have desired number of samples.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_train_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                        Generating random samples inside a Simplex</span>
<span class="c1">########################################################################################################################</span>
<span class="k">class</span> <span class="nc">Simplex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>

<span class="sd">            Generate random samples inside a simplex using uniform probability distribution.</span>

<span class="sd">            References:</span>
<span class="sd">            W. N. Edelinga, R. P. Dwightb, P. Cinnellaa, &quot;Simplex-stochastic collocation method with improved</span>
<span class="sd">                calability&quot;,Journal of Computational Physics, 310:301328 2016.</span>
<span class="sd">        Input:</span>
<span class="sd">            :param nodes: The vertices of the simplex</span>
<span class="sd">            :type nodes: ndarray</span>

<span class="sd">            :param nsamples: The number of samples to be generated inside the simplex</span>
<span class="sd">            :type nsamples: int</span>
<span class="sd">        Output:</span>
<span class="sd">            :return samples: New generated samples</span>
<span class="sd">            :rtype samples: ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Dimitris G.Giovanis</span>
    <span class="c1"># Last modified: 11/28/2018 by Mohit S. Chauhan</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_sis</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dimension</span><span class="p">])</span>
                <span class="n">ad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">b_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                        <span class="n">ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="n">b_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="n">ad</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">b_</span><span class="p">))</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">r_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">init_sis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Number of samples to be generated &#39;nsamples&#39; should be a positive &quot;</span>
                                      <span class="s2">&quot;integer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Size of simplex (nodes) is not consistent.&quot;</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                  Adaptive Kriging-Monte Carlo Simulation (AK-MCS)</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">AKMCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Description:</span>

<span class="sd">            Generate new samples using different active learning method and properties of kriging surrogate along with</span>
<span class="sd">            MCS.</span>

<span class="sd">            References:</span>
<span class="sd">        Input:</span>
<span class="sd">            :param model: Python model which is used to evaluate the function value</span>
<span class="sd">            :type model: str</span>

<span class="sd">            :param dist_name: A list containing the names of the distributions of the random variables.</span>
<span class="sd">                              Distribution names must match those in the Distributions module.</span>
<span class="sd">                              If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                              provide custom_dist.py.</span>
<span class="sd">                              The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                              dimension.</span>
<span class="sd">            :type dist_name: string list</span>

<span class="sd">            :param dist_params: Parameters of the distribution</span>
<span class="sd">                                Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                                Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                                distribution, dist[i].</span>
<span class="sd">            :type dist_params: list</span>

<span class="sd">            :param nsamples: Number of samples to generate.</span>
<span class="sd">            No Default Value: nsamples must be prescribed.</span>
<span class="sd">            :type nsamples: int</span>

<span class="sd">            :param doe: Design of Experiment.</span>
<span class="sd">            :type doe: ndarray</span>

<span class="sd">            :param population: Monte Carlo Population, new samples are selected from this set of points.</span>
<span class="sd">            :type doe: ndarray</span>

<span class="sd">            :param n_doe: Number of samples to be selected as design point from Population. It is only required if</span>
<span class="sd">                          design points are not define.</span>
<span class="sd">            :type n_doe: int</span>

<span class="sd">            :param lf: Learning function used as selection criteria to identify the new samples.</span>
<span class="sd">                       Options: U, Weighted-U, EFF, EIF and EGIF</span>
<span class="sd">            :type n_doe: str</span>

<span class="sd">            :param n_add: Number of samples to be selected per iteration.</span>
<span class="sd">            :type n_add: int</span>

<span class="sd">            :param min_cov: Minimum Covariance used as the stopping criteria of AKMCS method in case of relaibilty</span>
<span class="sd">                            analysis.</span>
<span class="sd">            :type min_cov: int</span>

<span class="sd">            :param n_stop: Final number of samples to be selected as design point from Population.</span>
<span class="sd">            :type n_stop: int</span>

<span class="sd">            :param max_p: Maximum possible value of probabilty density function of samples. Only required with</span>
<span class="sd">                          &#39;Weighted-U&#39; learning function.</span>
<span class="sd">            :type max_p: float</span>

<span class="sd">            :param reg_model: Regression model used to estimate gradient by using kriging surrogate. Only required</span>
<span class="sd">                               if kriging is used as surrogate approximation.</span>
<span class="sd">            :type reg_model: str</span>

<span class="sd">            :param corr_model: Correlation model used to estimate gradient by using kriging surrogate. Only required</span>
<span class="sd">                               if kriging is used as surrogate approximation.</span>
<span class="sd">            :type corr_model: str</span>

<span class="sd">            :param corr_model_params: Correlation model parameters used to estimate hyperparamters for kriging</span>
<span class="sd">                                      surrogate.</span>
<span class="sd">            :type corr_model_params: ndarray</span>

<span class="sd">            :param n_opt: Number of times optimization problem is to be solved with different starting point.</span>
<span class="sd">                          Default: 1</span>
<span class="sd">            :type n_opt: int</span>

<span class="sd">        Output:</span>
<span class="sd">            :return: AKMCS.DoE: Final/expanded samples.</span>
<span class="sd">            :rtype: AKMCS.DoE: ndarray</span>

<span class="sd">            :return: AKMCS.values:</span>
<span class="sd">            :rtype: AKMCS.values: ndarray</span>

<span class="sd">            :return: AKMCS.pr: Prediction function for the final surrogate model.</span>
<span class="sd">            :rtype: AKMCS.pf: function</span>

<span class="sd">            :return: AKMCS.pf: Probability of failure. Available as an output only after Reliability Analysis.</span>
<span class="sd">            :rtype: AKMCS.pf: int</span>

<span class="sd">            :return: AKMCS.cov_pf: Covariance of probability of failure.  Available as an output only after Reliability</span>
<span class="sd">                                   Analysis.</span>
<span class="sd">            :rtype: AKMCS.pf: int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Mohit S. Chauhan</span>
    <span class="c1"># Last modified: 08/04/2019 by Mohit S. Chauhan</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doe</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_doe</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span>
                 <span class="n">reg_model</span><span class="o">=</span><span class="s1">&#39;Linear&#39;</span><span class="p">,</span> <span class="n">corr_model_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_opt</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span> <span class="o">=</span> <span class="n">doe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_DoE</span> <span class="o">=</span> <span class="n">n_doe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span> <span class="o">=</span> <span class="n">corr_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">corr_model_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span> <span class="o">=</span> <span class="n">reg_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_opt</span> <span class="o">=</span> <span class="n">n_opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_stop</span> <span class="o">=</span> <span class="n">n_stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cov</span> <span class="o">=</span> <span class="n">min_cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_p</span> <span class="o">=</span> <span class="n">max_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">population</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">=</span> <span class="s1">&#39;UQpy&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_akmcs</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">==</span> <span class="s1">&#39;Reliability&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_akmcs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_akmcs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_akmcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">UQpy.RunModel</span> <span class="k">import</span> <span class="n">RunModel</span>
        <span class="kn">from</span> <span class="nn">UQpy.Surrogates</span> <span class="k">import</span> <span class="n">Krig</span>
        <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing AK-MCS design...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">MCS</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_DoE</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">RunModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">model_script</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">==</span> <span class="s1">&#39;Reliability&#39;</span><span class="p">:</span>
            <span class="n">pf</span><span class="p">,</span> <span class="n">cov_pf</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">cov_pf</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cov</span><span class="p">:</span>
                <span class="n">n_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">Krig</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span> <span class="n">reg_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span>
                                 <span class="n">corr_model_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_opt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_opt</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">corr_model_params</span>
                    <span class="n">interpolate</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">interpolate</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                    <span class="n">interpolate</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">rest_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
                        <span class="n">new</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">(</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">:</span>
                        <span class="n">new</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_u</span><span class="p">(</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EFF&#39;</span><span class="p">:</span>
                        <span class="n">new</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff</span><span class="p">(</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>

                    <span class="n">v_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">RunModel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="n">model_script</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">values</span><span class="p">,</span> <span class="n">v_new</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">ind</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="n">Krig</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span>
                                     <span class="n">reg_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span> <span class="n">corr_model_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">corr_model_params</span>
                        <span class="n">interpolate</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">interpolate</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                        <span class="n">interpolate</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

                <span class="n">pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_</span>
                <span class="n">cov_pf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pf</span> <span class="o">*</span> <span class="n">n_</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stop</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">cov_pf</span><span class="p">,</span> <span class="n">interpolate</span>
                <span class="k">if</span> <span class="n">cov_pf</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cov</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Covariance of pf = &quot;</span><span class="p">,</span> <span class="n">cov_pf</span><span class="p">,</span> <span class="s2">&quot;   Notice: Increasing total population by 20%&quot;</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">MCS</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">nsamples</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">samples</span><span class="p">])</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">cov_pf</span><span class="p">,</span> <span class="n">interpolate</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">==</span> <span class="s1">&#39;Sensitivity&#39;</span><span class="p">:</span>
            <span class="n">n_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">Krig</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span> <span class="n">reg_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span>
                             <span class="n">corr_model_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_opt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_opt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">corr_model_params</span>
                <span class="n">interpolate</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">interpolate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                <span class="n">interpolate</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_stop</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">rest_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EIF&#39;</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eif</span><span class="p">(</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EGIF&#39;</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">new</span><span class="p">])</span>

                <span class="n">v_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">RunModel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="n">model_script</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">values</span><span class="p">,</span> <span class="n">v_new</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">Krig</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">corr_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">,</span> <span class="n">reg_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_model</span><span class="p">,</span>
                                 <span class="n">corr_model_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_opt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">corr_model_params</span>
                    <span class="n">interpolate</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">interpolate</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model_params</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                    <span class="n">interpolate</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">interpolate</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: &#39;analysis&#39; should be &#39;Reliability&#39; or &#39;Sensitivity&#39;.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="c1"># U-function</span>
        <span class="c1"># References: B. Echard, N. Gayton and M. Lemaire, &quot;AK-MCS: An active learning reliability method combining</span>
        <span class="c1"># Kriging and Monte Carlo Simulation&quot;, Structural Safety, Pages 145-154, 2011.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># sig[sig == 0.] = 0.00001</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># print(g[rows])</span>
        <span class="k">return</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:],</span> <span class="n">indicator</span><span class="p">,</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">weighted_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p_</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
        <span class="c1"># Probability Weighted U-function</span>
        <span class="c1"># References: V.S. Sundar and M.S. Shields, &quot;RELIABILITY ANALYSIS USING ADAPTIVE KRIGING SURROGATES WITH</span>
        <span class="c1"># MULTIMODEL INFERENCE&quot;.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p_</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_p</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># print(g[rows])</span>
        <span class="k">return</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:],</span> <span class="n">indicator</span><span class="p">,</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="c1"># Expected Feasibilty Function (EFF)</span>
        <span class="c1"># References: B.J. Bichon, M.S. Eldred, L.P.Swiler, S. Mahadevan, J.M. McFarland, &quot;Efficient Global Reliability</span>
        <span class="c1"># Analysis for Nonlinear Implicit Performance Functions&quot;, AIAA JOURNAL, Volume 46, 2008.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="c1"># Reliability threshold: a_ = 0</span>
        <span class="c1"># EGRA method: epshilon = 2*sigma(x)</span>
        <span class="n">a_</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sig</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">+</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">eff</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">a_</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="o">-</span><span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="n">ep</span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>
        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">eff</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:],</span> <span class="n">indicator</span><span class="p">,</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">eif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">fm</span><span class="p">):</span>
        <span class="c1"># Expected Improvement Function (EIF)</span>
        <span class="c1"># References: D.R. Jones, M. Schonlau, W.J. Welch, &quot;Efficient Global Optimization of Expensive Black-Box</span>
        <span class="c1"># Functions&quot;, Journal of Global Optimization, Pages 455492, 1998.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="o">+</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="k">def</span> <span class="nf">eigf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="c1"># Expected Improvement for Global Fit (EIGF)</span>
        <span class="c1"># Refrence: J.N Fuhg, &quot;Adaptive surrogate models for parametric studies&quot;, Master&#39;s Thesis</span>
        <span class="c1"># Link: https://arxiv.org/pdf/1905.05345.pdf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">dis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">closest_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">closest_point</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DoE</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="n">index</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sig</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="k">def</span> <span class="nf">init_akmcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Model should be defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">DoE</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_DoE</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Define either &#39;doe&#39; or &#39;n_doe&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">,</span> <span class="s1">&#39;EIF&#39;</span><span class="p">,</span> <span class="s1">&#39;EGIF&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="s1">&#39;Reliability&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="s1">&#39;Sensitivity&#39;</span>

            <span class="c1"># self.lf = self.learning()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Doesn&#39;t recognize the active learning function.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_model</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;str&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">=</span> <span class="s1">&#39;Sklearn&#39;</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Markov Chain Monte Carlo</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCMC"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC">[docs]</a><span class="k">class</span> <span class="nc">MCMC</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>
<span class="sd">            Generate samples from arbitrary user-specified probability density function using Markov Chain Monte Carlo.</span>
<span class="sd">            This class generates samples using Metropolis-Hastings(MH), Modified Metropolis-Hastings,</span>
<span class="sd">            or Affine Invariant Ensemble Sampler with stretch moves.</span>
<span class="sd">            References:</span>
<span class="sd">            S.-K. Au and J. L. Beck,Estimation of small failure probabilities in high dimensions by subset simulation,</span>
<span class="sd">                Probabilistic Eng. Mech., vol. 16, no. 4, pp. 263277, Oct. 2001.</span>
<span class="sd">            J. Goodman and J. Weare, Ensemble samplers with affine invariance, Commun. Appl. Math. Comput. Sci.,vol.5,</span>
<span class="sd">                no. 1, pp. 6580, 2010.</span>
<span class="sd">        Input:</span>
<span class="sd">            :param dimension: A scalar value defining the dimension of target density function.</span>
<span class="sd">                              Default: 1</span>
<span class="sd">            :type dimension: int</span>
<span class="sd">            :param pdf_proposal_type: Type of proposal density function for MCMC. Only used with algorithm =&#39;MH&#39; or&#39;MMH&#39;</span>
<span class="sd">                            Options:</span>
<span class="sd">                                    &#39;Normal&#39; : Normal proposal density.</span>
<span class="sd">                                    &#39;Uniform&#39; : Uniform proposal density.</span>
<span class="sd">                            Default: &#39;Uniform&#39;</span>
<span class="sd">                            If dimension &gt; 1 and algorithm = &#39;MMH&#39;, this may be input as a list to assign different</span>
<span class="sd">                            proposal densities to each dimension. Example pdf_proposal_name = [&#39;Normal&#39;,&#39;Uniform&#39;].</span>
<span class="sd">                            If dimension &gt; 1, algorithm = &#39;MMH&#39; and this is input as a string, the proposal densities</span>
<span class="sd">                            for all dimensions are set equal to the assigned proposal type.</span>
<span class="sd">            :type pdf_proposal_type: str or str list</span>
<span class="sd">            :param pdf_proposal_scale: Scale of the proposal distribution</span>
<span class="sd">                            If algorithm == &#39;MH&#39; or &#39;MMH&#39;</span>
<span class="sd">                                For pdf_proposal_type = &#39;Uniform&#39;</span>
<span class="sd">                                    Proposal is Uniform in [x-pdf_proposal_scale/2, x+pdf_proposal_scale/2].</span>
<span class="sd">                                For pdf_proposal_type = &#39;Normal&#39;</span>
<span class="sd">                                    Proposal is Normal with standard deviation equal to pdf_proposal_scale.</span>
<span class="sd">                            If algorithm == &#39;Stretch&#39;</span>
<span class="sd">                                pdf_proposal_scale sets the scale of the stretch density.</span>
<span class="sd">                                    g(z) = 1/sqrt(z) for z in [1/pdf_proposal_scale, pdf_proposal_scale].</span>
<span class="sd">                            Default value: dimension x 1 list of ones.</span>
<span class="sd">            :type pdf_proposal_scale: float or float list</span>
<span class="sd">                            If dimension &gt; 1, this may be defined as float or float list.</span>
<span class="sd">                                If input as float, pdf_proposal_scale is assigned to all dimensions.</span>
<span class="sd">                                If input as float list, each element is assigned to the corresponding dimension.</span>
<span class="sd">            :param pdf_target: Target density function from which to draw random samples</span>
<span class="sd">                            The target joint probability density must be a function, or list of functions, or a string.</span>
<span class="sd">                            If type == &#39;str&#39;</span>
<span class="sd">                                The assigned string must refer to a custom pdf defined in the file custom_pdf.py in the</span>
<span class="sd">                                 working directory.</span>
<span class="sd">                            If type == function</span>
<span class="sd">                                The function must be defined in the python script calling MCMC.</span>
<span class="sd">                            If dimension &gt; 1 and pdf_target_type=&#39;marginal_pdf&#39;, the input to pdf_target is a list of</span>
<span class="sd">                            size [dimensions x 1] where each item of the list defines a marginal pdf.</span>
<span class="sd">                            Default: Multivariate normal distribution having zero mean and unit standard deviation.</span>
<span class="sd">            :type pdf_target: function, function list, or str</span>
<span class="sd">            :param pdf_target_params: Parameters of the target pdf.</span>
<span class="sd">            :type pdf_target_params: list</span>
<span class="sd">            :param algorithm:  Algorithm used to generate random samples.</span>
<span class="sd">                            Options:</span>
<span class="sd">                                &#39;MH&#39;: Metropolis Hastings Algorithm</span>
<span class="sd">                                &#39;MMH&#39;: Component-wise Modified Metropolis Hastings Algorithm</span>
<span class="sd">                                &#39;Stretch&#39;: Affine Invariant Ensemble MCMC with stretch moves</span>
<span class="sd">                            Default: &#39;MMH&#39;</span>
<span class="sd">            :type algorithm: str</span>
<span class="sd">            :param jump: Number of samples between accepted states of the Markov chain.</span>
<span class="sd">                                Default value: 1 (Accepts every state)</span>
<span class="sd">            :type: jump: int</span>
<span class="sd">            :param nsamples: Number of samples to generate</span>
<span class="sd">                                No Default Value: nsamples must be prescribed</span>
<span class="sd">            :type nsamples: int</span>
<span class="sd">            :param seed: Seed of the Markov chain(s)</span>
<span class="sd">                            For &#39;MH&#39; and &#39;MMH&#39;, this is a single point, defined as a numpy array of dimension</span>
<span class="sd">                             (1 x dimension).</span>
<span class="sd">                            For &#39;Stretch&#39;, this is a numpy array of dimension N x dimension, where N is the ensemble</span>
<span class="sd">                            size.</span>
<span class="sd">                            Default:</span>
<span class="sd">                                For &#39;MH&#39; and &#39;MMH&#39;: zeros(1 x dimension)</span>
<span class="sd">                                For &#39;Stretch&#39;: No default, this must be specified.</span>
<span class="sd">            :type seed: float or numpy array</span>
<span class="sd">            :param nburn: Length of burn-in. Number of samples at the beginning of the chain to discard.</span>
<span class="sd">                            This option is only used for the &#39;MMH&#39; and &#39;MH&#39; algorithms.</span>
<span class="sd">                            Default: nburn = 0</span>
<span class="sd">            :type nburn: int</span>
<span class="sd">        Output:</span>
<span class="sd">            :return: MCMC.samples: Set of MCMC samples following the target distribution</span>
<span class="sd">            :rtype: MCMC.samples: ndarray</span>

<span class="sd">            :return: MCMC.accept_ratio: Acceptance ratio of the MCMC samples</span>
<span class="sd">            :rtype: MCMC.accept_ratio: float</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Michael D. Shields, Mohit Chauhan, Dimitris G. Giovanis</span>
    <span class="c1"># Updated: 04/08/2019 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_proposal_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_proposal_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_copula</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_target_copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_type</span><span class="o">=</span><span class="s1">&#39;joint_pdf&#39;</span><span class="p">,</span>
                 <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;MH&#39;</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="n">pdf_proposal_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="n">pdf_proposal_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="o">=</span> <span class="n">pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">log_pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="o">=</span> <span class="n">pdf_target_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span> <span class="o">=</span> <span class="n">pdf_target_copula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="o">=</span> <span class="n">pdf_target_copula_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">=</span> <span class="n">nburn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">=</span> <span class="n">pdf_target_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_mcmc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">accept_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n_accepts</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Defining an array to store the generated samples</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Classical Metropolis-Hastings Algorithm with symmetric proposal density</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;MH&#39;</span><span class="p">:</span>
            <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span>
            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

            <span class="c1"># Loop over the samples</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Normal&#39;</span><span class="p">:</span>
                    <span class="n">cholesky_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span>
                    <span class="n">z_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">cholesky_cov</span><span class="p">,</span> <span class="n">z_normal</span><span class="p">)</span>
                    <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                    <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                        <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                        <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Uniform&#39;</span><span class="p">:</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
                    <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                    <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                        <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                        <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">accept_ratio</span> <span class="o">=</span> <span class="n">n_accepts</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Modified Metropolis-Hastings Algorithm with symmetric proposal density</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;MMH&#39;</span><span class="p">:</span>

            <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">==</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">:</span>
                <span class="n">list_log_p_current</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">list_log_p_current</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>

                        <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Normal&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                                <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                                <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Uniform&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                          <span class="n">high</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                                <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                                <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">):</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Normal&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Uniform&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                             <span class="n">high</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                             <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                        <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                        <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                        <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                            <span class="n">current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                            <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">accept_ratio</span> <span class="o">=</span> <span class="n">n_accepts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Affine Invariant Ensemble Sampler with stretch moves</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>

            <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>
            <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span>
            <span class="c1"># list_log_p_current = [log_pdf_(samples[i, :], self.pdf_target_params) for i in range(self.ensemble_size)]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">complementary_ensemble</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">s0</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">complementary_ensemble</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">s0</span><span class="p">)</span>

                <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
                <span class="c1"># log_p_current = list_log_p_current[i - self.ensemble_size + 1]</span>
                <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">s</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
                    <span class="c1"># list_log_p_current.append(log_p_candidate)</span>
                    <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="c1"># list_log_p_current.append(list_log_p_current[i - self.ensemble_size + 1])</span>
            <span class="n">accept_ratio</span> <span class="o">=</span> <span class="n">n_accepts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">)</span>


        <span class="c1">################################################################################################################</span>
        <span class="c1"># Return the samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MMH&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MH&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Successful execution of the MCMC design&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">],</span> <span class="n">accept_ratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">accept_ratio</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Check to ensure consistency of the user input and assign defaults</span>
    <span class="k">def</span> <span class="nf">init_mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Check dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Check nsamples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Exit code: Number of samples not defined.&#39;</span><span class="p">)</span>

        <span class="c1"># Check nburn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Check jump</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Exit code: Value of jump must be greater than 0&quot;</span><span class="p">)</span>

        <span class="c1"># Check seed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;seed&#39;.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;For Stretch algorithm, a seed must be given as a ndarray&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;seed&#39;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Ensemble size must be &gt; 2.&quot;</span><span class="p">)</span>

        <span class="c1"># Check algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;MH&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;MH&#39;</span><span class="p">,</span> <span class="s1">&#39;MMH&#39;</span><span class="p">,</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Exit code: Unrecognized MCMC algorithm. Supported algorithms: &#39;</span>
                                      <span class="s1">&#39;Metropolis-Hastings (MH), &#39;</span>
                                      <span class="s1">&#39;Modified Metropolis-Hastings (MMH), &#39;</span>
                                      <span class="s1">&#39;Affine Invariant Ensemble with Stretch Moves (Stretch).&#39;</span><span class="p">)</span>

        <span class="c1"># Check pdf_proposal_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="s1">&#39;Normal&#39;</span>
        <span class="c1"># If pdf_proposal_type is entered as a string, make it a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;Normal&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: Unrecognized type for proposal distribution. Supported distributions: &#39;</span>
                                 <span class="s1">&#39;Uniform, &#39;</span>
                                 <span class="s1">&#39;Normal.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MH&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: MH algorithm can only take one proposal distribution.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;pdf_proposal_type&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Check pdf_proposal_scale</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;pdf_proposal_scale&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Check log_pdf_target and pdf_target</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: a target function must be provided, in log_pdf_target of pdf_target&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: inconsistent dimensions.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: inconsistent dimensions.&#39;</span><span class="p">)</span>

        <span class="c1"># Check pdf_target_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;joint_pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target_type should be &quot;joint_pdf&quot;, &quot;marginal_pdf&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Check MMH</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MMH&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">==</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: MMH with pdf_target_type=&quot;marginal&quot; cannot be used when the&#39;</span>
                                 <span class="s1">&#39;target pdf has a copula, use pdf_target_type=&quot;joint&quot; instead&#39;</span><span class="p">)</span>

        <span class="c1"># If pdf_target or log_pdf_target are given as lists, they should be of the right dimension</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a list should have length equal to dimension&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target_params should be given as a list of length equal to log_pdf_target&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a list should have length equal to dimension&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target_params should be given as a list of length equal to pdf_target&#39;</span><span class="p">)</span>


        <span class="c1"># Define a helper function</span>
        <span class="k">def</span> <span class="nf">compute_log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf_func</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">kwargs_</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs_</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">if</span> <span class="n">copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs_</span><span class="p">[</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copula_params</span>
            <span class="n">pdf_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pdf_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pdf_value</span><span class="p">)</span>

        <span class="c1"># Either pdf_target or log_pdf_target must be defined</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The target distribution must be defined, using inputs&#39;</span>
                             <span class="s1">&#39; log_pdf_target or pdf_target.&#39;</span><span class="p">)</span>
        <span class="c1"># For MMH with pdf_target_type == &#39;marginals&#39;, pdf_target or its log should be lists</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;MMH&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">==</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[{}]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MMH algo with pdf_target_type=&quot;marginal_pdf&quot;, &#39;</span>
                                     <span class="s1">&#39;log_pdf_target should be a list&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">p_js</span> <span class="o">=</span> <span class="p">[</span><span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">pdf_target_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdf_target_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">p_j</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">p_j</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a list of strings must point to Distributions &#39;</span>
                                             <span class="s1">&#39;with an existing log_pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">pdf_target_j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pdf_target_j</span><span class="p">)</span>
                                           <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target must be a list of strings or a list of callables&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MMH algo with pdf_target_type=&quot;marginal_pdf&quot;, &#39;</span>
                                     <span class="s1">&#39;pdf_target should be a list&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">p_js</span> <span class="o">=</span> <span class="p">[</span><span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">pdf_target_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdf_target_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">p_j</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">p_j</span><span class="o">.</span><span class="n">pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                               <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a list of strings must point to Distributions &#39;</span>
                                             <span class="s1">&#39;with an existing pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">pdf_target_j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                           <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pdf_target_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target must be a list of strings or a list of callables&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                                                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a string must point to a Distribution &#39;</span>
                                             <span class="s1">&#39;with an existing log_pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MH and Stretch, log_pdf_target must be a callable function, &#39;</span>
                                     <span class="s1">&#39;a str or list of str&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                                                        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a string must point to a Distribution &#39;</span>
                                             <span class="s1">&#39;with an existing pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MH and Stretch, pdf_target must be a callable function, &#39;</span>
                                     <span class="s1">&#39;a str or list of str&#39;</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Importance Sampling</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="IS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS">[docs]</a><span class="k">class</span> <span class="nc">IS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>

<span class="sd">            Perform Importance Sampling (IS) of independent random variables given a target and a</span>
<span class="sd">            proposal distribution.</span>

<span class="sd">        Input:</span>

<span class="sd">            :param pdf_proposal: A list containing the names of the proposal distribution for each random variable.</span>
<span class="sd">                                 Distribution names must match those in the Distributions module.</span>
<span class="sd">                                 If the distribution does not match one from the Distributions module, the user</span>
<span class="sd">                                 must provide custom_dist.py. The length of the string must be 1 (if all</span>
<span class="sd">                                 distributions are the same) or equal to dimension.</span>
<span class="sd">            :type pdf_proposal: string list</span>

<span class="sd">            :param pdf_proposal_params: Parameters of the proposal distribution.</span>
<span class="sd">                                        Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                                        Each item in the list, pdf_proposal_params[i], specifies the parameters for the</span>
<span class="sd">                                        corresponding proposal distribution, pdf_proposal[i].</span>
<span class="sd">            :type pdf_proposal_params: list</span>

<span class="sd">            :param pdf_target: A list containing the names of the target distribution for each random variable.</span>
<span class="sd">                                 Distribution names must match those in the Distributions module.</span>
<span class="sd">                                 If the distribution does not match one from the Distributions module, the user</span>
<span class="sd">                                 must provide custom_dist.py. The length of the string must be 1 (if all</span>
<span class="sd">                                 distributions are the same) or equal to dimension.</span>
<span class="sd">            :type pdf_target: string list</span>

<span class="sd">            :param pdf_target_params: Parameters of the target distribution.</span>
<span class="sd">                                        Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                                        Each item in the list, pdf_target_params[i], specifies the parameters for the</span>
<span class="sd">                                        corresponding target distribution, pdf_target[i].</span>
<span class="sd">            :type pdf_target_params: list</span>

<span class="sd">            :param nsamples: Number of samples to generate.</span>
<span class="sd">                             No Default Value: nsamples must be prescribed.</span>
<span class="sd">            :type nsamples: int</span>

<span class="sd">        Output:</span>
<span class="sd">            :return: IS.samples: Set of generated samples</span>
<span class="sd">            :rtype: IS.samples: ndarray</span>

<span class="sd">            :return: IS.weights: Importance weights of samples</span>
<span class="sd">            :rtype: IS.weights: ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Dimitris G.Giovanis</span>
    <span class="c1"># Last Modified: 04/08/2019 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_proposal_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_target_copula</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_copula_params</span><span class="o">=</span><span class="kc">None</span>
                 <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span> <span class="o">=</span> <span class="n">pdf_proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_params</span> <span class="o">=</span> <span class="n">pdf_proposal_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="o">=</span> <span class="n">pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">log_pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="o">=</span> <span class="n">pdf_target_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span> <span class="o">=</span> <span class="n">pdf_target_copula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="o">=</span> <span class="n">pdf_target_copula_params</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_is</span><span class="p">()</span>

        <span class="c1"># Step 1: sample from proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_step</span><span class="p">()</span>
        <span class="c1"># Step 2: weight samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting_step</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sampling_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">proposal_pdf_</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">proposal_pdf_</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="k">def</span> <span class="nf">weighting_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="c1"># evaluate qs (log_pdf_proposal)</span>
        <span class="n">proposal_pdf_</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">log_qs</span> <span class="o">=</span> <span class="n">proposal_pdf_</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_params</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">log_qs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">proposal_pdf_</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_params</span><span class="p">))</span>
        <span class="c1"># evaluate ps (log_pdf_target)</span>
        <span class="n">log_ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">log_weights</span> <span class="o">=</span> <span class="n">log_ps</span><span class="o">-</span><span class="n">log_qs</span>
        <span class="c1"># this rescale is used to avoid having NaN of Inf when taking the exp</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_weights</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">log_weights</span><span class="p">))</span>
        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">log_weights</span><span class="p">,</span> <span class="n">weights</span><span class="o">/</span><span class="n">sum_w</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.Utilities</span> <span class="k">import</span> <span class="n">resample</span>
        <span class="k">return</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

    <span class="c1">################################################################################################################</span>
    <span class="c1"># Initialize Importance Sampling.</span>

    <span class="k">def</span> <span class="nf">init_is</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Check nsamples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Exit code: Number of samples is not defined.&#39;</span><span class="p">)</span>

        <span class="c1"># helper function</span>
        <span class="k">def</span> <span class="nf">compute_log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf_func</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="p">):</span>
            <span class="n">kwargs_</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs_</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">if</span> <span class="n">copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs_</span><span class="p">[</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copula_params</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">pdf_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">)</span>
            <span class="n">pdf_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pdf_value</span><span class="p">)</span>
        <span class="c1"># Check log_pdf_target, pdf_target</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: a target pdf must be defined (pdf_target or log_pdf_target).&#39;</span><span class="p">)</span>
        <span class="c1"># The code first checks if log_pdf_target is defined, if yes, no need to check pdf_target</span>
        <span class="n">x_test</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># log_pdf_target can be defined as a callable or string.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                                                        <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_test</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a string must point to a Distribution &#39;</span>
                                         <span class="s1">&#39;with an existing log_pdf method.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target should be a callable or a string/list of strings.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pdf_target can be a str of list of strings, then compute the log_pdf</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                                                    <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_test</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a string must point to a Distribution &#39;</span>
                                         <span class="s1">&#39;with an existing pdf method.&#39;</span><span class="p">)</span>
            <span class="c1"># otherwise it may be a function that computes the pdf, then just take the logarithm</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target should be a callable or a string/list of strings.&#39;</span><span class="p">)</span>

        <span class="c1"># Check pdf_proposal_name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: A proposal distribution is required.&#39;</span><span class="p">)</span>
        <span class="c1"># can be given as a name or a list of names, transform it to a distribution class</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: proposal pdf must be given as a str or a list of str&#39;</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../runmodel.html">RunModel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplemethods.html">SampleMethods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stochastic_process.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surrogates.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reliability.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dimension_reduction.html">DimensionReduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, SURG, JHU.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>
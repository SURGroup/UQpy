
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>UQpy.SampleMethods &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for UQpy.SampleMethods</h1><div class="highlight"><pre>
<span></span><span class="c1"># UQpy is distributed under the MIT license.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018  -- Michael D. Shields</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the</span>
<span class="c1"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="c1"># persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of the</span>
<span class="c1"># Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="c1"># COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="c1"># OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;This module contains functionality for all the sampling methods supported in ``UQpy``.</span>

<span class="sd">The module currently contains the following classes:</span>

<span class="sd">- ``MCS``: Class to perform Monte Carlo sampling.</span>
<span class="sd">- ``LHS``: Class to perform Latin hypercube sampling.</span>
<span class="sd">- ``MCMC``: Class to perform Markov Chain Monte Carlo sampling.</span>
<span class="sd">- ``IS``: Class to perform Importance sampling.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span>

<span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="o">*</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Monte Carlo Simulation</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS">[docs]</a><span class="k">class</span> <span class="nc">MCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Monte Carlo sampling (MCS) of random variables.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">        Probability distribution of each random variable. Must be an object (or a list of objects) of the</span>
<span class="sd">        ``Distribution`` class.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to be drawn from each distribution.</span>

<span class="sd">        The ``run`` method is automatically called if `nsamples` is provided. If `nsamples` is not provided, then the</span>
<span class="sd">        ``MCS`` object is created but samples are not generated.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (Boolean):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray` or `list`):</span>
<span class="sd">        Generated samples.</span>

<span class="sd">        If a list of ``DistributionContinuous1D`` objects is provided for ``dist_object``, then `samples` is an</span>
<span class="sd">        `ndarray` with ``samples.shape=(nsamples, len(dist_object))``.</span>

<span class="sd">        If a ``DistributionContinuous1D`` object is provided for ``dist_object`` then `samples` is an array with</span>
<span class="sd">        `samples.shape=(nsamples, 1)``.</span>

<span class="sd">        If a ``DistributionContinuousND`` object is provided for ``dist_object`` then `samples` is an array with</span>
<span class="sd">        ``samples.shape=(nsamples, ND)``.</span>

<span class="sd">        If a list of mixed ``DistributionContinuous1D`` and ``DistributionContinuousND`` objects is provided then</span>
<span class="sd">        `samples` is a list with ``len(samples)=nsamples`` and ``len(samples[i]) = len(dist_object)``.</span>

<span class="sd">    * **samplesU01** (`ndarray` (`list`)):</span>
<span class="sd">        Generated samples transformed to the unit hypercube.</span>

<span class="sd">        This attribute exists only if the ``transform_u01`` method is invoked by the user.</span>


<span class="sd">    **Methods**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">add_continuous_1d</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">add_continuous_nd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Distribution</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A UQpy.Distribution object must be provided.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="n">add_continuous_1d</span> <span class="o">=</span> <span class="n">add_continuous_1d</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionND</span><span class="p">):</span>
                    <span class="n">add_continuous_nd</span> <span class="o">=</span> <span class="n">add_continuous_nd</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">add_continuous_1d</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A UQpy.Distribution object must be provided.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="c1"># Instantiate the output attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set printing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="c1"># Run Monte Carlo sampling</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

<div class="viewcode-block" id="MCS.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the random sampling in the ``MCS`` class.</span>

<span class="sd">        The ``run`` method is the function that performs random sampling in the ``MCS`` class. If `nsamples` is</span>
<span class="sd">        provided, the ``run`` method is automatically called when the ``MCS`` object is defined. The user may also call</span>
<span class="sd">        the ``run`` method directly to generate samples. The ``run`` method of the ``MCS`` class can be invoked many</span>
<span class="sd">        times and each time the generated samples are appended to the existing samples.</span>

<span class="sd">        ** Input:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to be drawn from each distribution.</span>

<span class="sd">            If the ``run`` method is invoked multiple times, the newly generated samples will be appended to the</span>
<span class="sd">            existing samples.</span>

<span class="sd">        * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">            Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">            If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">            object itself can be passed directly.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples` attribute of the ``MCS``</span>
<span class="sd">        class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if a random_state is provided.</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Number of samples must be defined.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples should be an integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Monte Carlo Sampling.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">temp_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
                    <span class="n">temp_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: rvs method is missing.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_samples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
                <span class="n">temp_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">temp_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If self.samples already has existing samples, append the new samples to the existing attribute.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Monte Carlo Sampling Complete.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MCS.transform_u01"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS.transform_u01">[docs]</a>    <span class="k">def</span> <span class="nf">transform_u01</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform random samples to uniform on the unit hypercube.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        The ``transform_u01`` method is an instance method that perform the transformation on an existing ``MCS``</span>
<span class="sd">        object. It takes no input.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``transform_u01`` method has no returns, although it creates and/or appends the `samplesU01` attribute of</span>
<span class="sd">        the ``MCS`` class.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                        <span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">zi</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">zi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">temp_samples_u01</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">][:]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                        <span class="n">zi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span>
                <span class="n">temp_samples_u01</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">temp_samples_u01</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Latin hypercube sampling  (LHS)</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="LHS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS">[docs]</a><span class="k">class</span> <span class="nc">LHS</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Latin hypercube sampling (MCS) of random variables.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">        List of ``Distribution`` objects corresponding to each random variable.</span>

<span class="sd">        All distributions in ``LHS`` must be independent. ``LHS`` does not generate correlated random variables.</span>
<span class="sd">        Therefore, for multi-variate designs the `dist_object` must be a list of ``DistributionContinuous1D`` objects</span>
<span class="sd">        or an object of the ``JointInd`` class.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to be drawn from each distribution.</span>

<span class="sd">    * **criterion** (`str` or `callable`):</span>
<span class="sd">        The criterion for pairing the generating sample points</span>
<span class="sd">            Options:</span>
<span class="sd">                1. &#39;random&#39; - completely random. \n</span>
<span class="sd">                2. &#39;centered&#39; - points only at the centre. \n</span>
<span class="sd">                3. &#39;maximin&#39; - maximizing the minimum distance between points. \n</span>
<span class="sd">                4. &#39;correlate&#39; - minimizing the correlation between the points. \n</span>
<span class="sd">                5. `callable` - User-defined method.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>

<span class="sd">    * ****kwargs**</span>
<span class="sd">        Additional arguments to be passed to the method specified by `criterion`</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        The generated LHS samples.</span>

<span class="sd">    * **samples_U01** (`ndarray`):</span>
<span class="sd">        The generated LHS samples on the unit hypercube.</span>

<span class="sd">    **Methods**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Check if a Distribution object is provided.</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D object must be provided.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D or JointInd object must be provided.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">,</span> <span class="s1">&#39;maximin&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported lhs criteria: &#39;random&#39;, &#39;centered&#39;, &#39;maximin&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;correlate&#39;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of samples must be specified.&#39;</span><span class="p">)</span>

        <span class="c1"># Set printing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="LHS.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the random sampling in the ``LHS`` class.</span>

<span class="sd">        The ``run`` method is the function that performs random sampling in the ``LHS`` class. If `nsamples` is</span>
<span class="sd">        provided, the ``run`` method is automatically called when the ``LHS`` object is defined. The user may also call</span>
<span class="sd">        the ``run`` method directly to generate samples. The ``run`` method of the ``LHS`` class cannot be invoked</span>
<span class="sd">        multiple times for sample size extension.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to be drawn from each distribution.</span>

<span class="sd">            If the ``run`` method is invoked multiple times, the newly generated samples will be overwrite the</span>
<span class="sd">            existing samples.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples` and `samples_U01` attributes</span>
<span class="sd">        of the ``LHS`` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Latin Hypercube sampling...&#39;</span><span class="p">)</span>

        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">u</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;centered&#39;</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;maximin&#39;</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_min</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;correlate&#39;</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: A valid criterion is required.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">u_lhs</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;icdf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">u_lhs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">u_lhs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">u_lhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Successful execution of LHS design.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LHS.random"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.random">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design by sampling randomly inside each bin.</span>

<span class="sd">        The ``random`` method takes a set of samples drawn randomly from within the Latin hypercube bins and performs a</span>
<span class="sd">        random shuffling of them to pair the variables.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each bin.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The randomly shuffled set of LHS samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div>

<div class="viewcode-block" id="LHS.max_min"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.max_min">[docs]</a>    <span class="k">def</span> <span class="nf">max_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design that aims to maximize the minimum sample distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each LHS bin.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        * **iterations** (`int`):</span>
<span class="sd">            The number of iteration to run in the search for a maximin design.</span>

<span class="sd">        * **metric** (`str` or `callable`):</span>
<span class="sd">            The distance metric to use.</span>
<span class="sd">                Options:</span>
<span class="sd">                    1. `str` - Available options are those supported by ``scipy.spatial.distance``</span>
<span class="sd">                    2. User-defined function to compute the distance between samples. This function replaces the</span>
<span class="sd">                       ``scipy.spatial.distance.pdist`` method.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The maximin set of LHS samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span> <span class="s1">&#39;canberra&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;dice&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;kulsinski&#39;</span><span class="p">,</span> <span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span> <span class="s1">&#39;matching&#39;</span><span class="p">,</span> <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span> <span class="s1">&#39;russellrao&#39;</span><span class="p">,</span> <span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span> <span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Exit code: Please provide a string corresponding to a distance metric&quot;</span>
                                          <span class="s2">&quot;supported by scipy.spatial.distance or provide a method to compute a user-&quot;</span>
                                          <span class="s2">&quot;defined distance.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of iterations must be an integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">d_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">pdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="n">d_func</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UQpy: Please provide a valid metric.&quot;</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d_func</span><span class="p">(</span><span class="n">lhs_samples</span><span class="p">)</span>
        <span class="n">max_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">:</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d_func</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_min_dist</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">max_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Achieved maximum distance of &#39;</span><span class="p">,</span> <span class="n">max_min_dist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div>

<div class="viewcode-block" id="LHS.correlate"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.correlate">[docs]</a>    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design that aims to minimize spurious correlations.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each LHS bin.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        * **iterations** (`int`):</span>
<span class="sd">            The number of iteration to run in the search for a maximin design.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The minimum correlation set of LHS samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of iterations must be an integer.&#39;</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">lhs_samples</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">:</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples_try</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_corr</span><span class="p">:</span>
                <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span>
                <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Achieved minimum correlation of &#39;</span><span class="p">,</span> <span class="n">min_corr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div>

<div class="viewcode-block" id="LHS.centered"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.centered">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">centered</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design with samples centered in the bins.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each LHS bin. In this method, the samples passed in are not used.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        * **a** (`ndarray`)</span>
<span class="sd">            An array of the bin lower-bounds.</span>

<span class="sd">        * **b** (`ndarray`)</span>
<span class="sd">            An array of the bin upper-bounds</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The centered set of LHS samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">u_temp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">u_temp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Stratified Sampling  (STS)</span>
<span class="c1">########################################################################################################################</span>
<span class="k">class</span> <span class="nc">STS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate samples from an assigned probability density function using Stratified Sampling.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. M.D. Shields, K. Teferra, A. Hapij, and R.P. Daddazio, &quot;Refined Stratified Sampling for efficient Monte</span>
<span class="sd">       Carlo based uncertainty quantification,&quot; Reliability Engineering and System Safety,vol.142, pp.310-325,2015.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dimension: A scalar value defining the dimension of target density function.</span>
<span class="sd">                      Default: Length of sts_design.</span>
<span class="sd">    :type dimension: int</span>

<span class="sd">    :param dist_name: A list containing the names of the distributions of the random variables.</span>
<span class="sd">                      Distribution names must match those in the Distributions module.</span>
<span class="sd">                      If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                      provide custom_dist.py.</span>
<span class="sd">                      The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                      dimension.</span>
<span class="sd">    :type dist_name: string list</span>

<span class="sd">    :param dist_params: Parameters of the distribution</span>
<span class="sd">                        Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                        Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                        distribution, dist[i].</span>
<span class="sd">    :type dist_params: list</span>

<span class="sd">    param: distribution: An object list containing the distributions of the random variables.</span>
<span class="sd">                         Each item in the list is an object of the Distribution class (see Distributions.py).</span>
<span class="sd">                         The list has length equal to dimension.</span>
<span class="sd">    :type distribution: list</span>

<span class="sd">    :param sts_design: Specifies the number of strata in each dimension</span>
<span class="sd">    :type sts_design: int list</span>

<span class="sd">    :param input_file: File path to input file specifying stratum origins and stratum widths.</span>
<span class="sd">                       Default: None.</span>
<span class="sd">    :type input_file: string</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :return: STS.samples: Set of stratified samples.</span>
<span class="sd">    :rtype: STS.samples: ndarray</span>

<span class="sd">    :return: STS.samplesU01: Set of uniform stratified samples on [0, 1]^dimension</span>
<span class="sd">    :rtype: STS.samplesU01: ndarray</span>

<span class="sd">    :return: STS.strata: Instance of the class SampleMethods.Strata</span>
<span class="sd">    :rtype: STS.strata: ndarray</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Michael Shields</span>
<span class="sd">    Last modified: 6/7/2018 by Dimitris Giovanis &amp; Michael Shields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sts_design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sts_criterion</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">stype</span><span class="o">=</span><span class="s1">&#39;Rectangular&#39;</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_iters</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">=</span> <span class="n">stype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="o">=</span> <span class="n">sts_design</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">=</span> <span class="n">sts_criterion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span> <span class="o">=</span> <span class="n">n_iters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_sts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_sts</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_sts</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute stratified sampling</span>

<span class="sd">        This is an instance method that runs stratified sampling. It is automatically called when the STS class is</span>
<span class="sd">        instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">samples_u_to_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                                          <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;centered&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>

                <span class="n">samples_u_to_x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Successful execution of STS design..&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">samples_u_to_x</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">,</span> <span class="n">voronoi_unit_hypercube</span>

            <span class="n">samples_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span><span class="p">):</span>
                <span class="c1"># x = self.in_hypercube(samples_init)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="n">samples_init</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="n">samples_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_points</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">in_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>

        <span class="n">in_cube</span> <span class="o">=</span> <span class="kc">True</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">in_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">in_cube</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">in_cube</span>

    <span class="k">def</span> <span class="nf">init_sts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>

        <span class="c1"># Check for dimensional consistency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Dimension must be specified.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_name</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of i_cdf should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_params</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of dist_params list should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure that distribution parameters are assigned</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Distribution parameters not defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Stratum design is not defined.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">Strata</span><span class="p">(</span><span class="n">input_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;sts_design&#39;.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">Strata</span><span class="p">(</span><span class="n">n_strata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span>

        <span class="c1"># Check sampling criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported sts criteria: &#39;random&#39;, &#39;centered&#39;&quot;</span><span class="p">)</span>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Strata</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">Strata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a rectilinear stratification of the n-dimensional unit hypercube [0, 1]^dimension with N strata.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param n_strata: A list of dimension n defining the number of strata in each of the n dimensions</span>
<span class="sd">                    Creates an equal stratification with strata widths equal to 1/n_strata</span>
<span class="sd">                    The total number of strata, N, is the product of the terms of n_strata</span>
<span class="sd">                    Example -</span>
<span class="sd">                    n_strata = [2, 3, 2] creates a 3d stratification with:</span>
<span class="sd">                    2 strata in dimension 0 with stratum widths 1/2</span>
<span class="sd">                    3 strata in dimension 1 with stratum widths 1/3</span>
<span class="sd">                    2 strata in dimension 2 with stratum widths 1/2</span>
<span class="sd">    :type n_strata int list</span>

<span class="sd">    :param input_file: File path to input file specifying stratum origins and stratum widths.</span>
<span class="sd">                       Default: None</span>
<span class="sd">    :type input_file: string</span>

<span class="sd">    :param origins: An array of dimension N x n specifying the origins of all strata</span>
<span class="sd">                    The origins of the strata are the coordinates of the stratum orthotope nearest the global</span>
<span class="sd">                    origin.</span>
<span class="sd">                    Example - A 2D stratification with 2 strata in each dimension</span>
<span class="sd">                    origins = [[0, 0]</span>
<span class="sd">                              [0, 0.5]</span>
<span class="sd">                              [0.5, 0]</span>
<span class="sd">                              [0.5, 0.5]]</span>
<span class="sd">    :type origins: numpy array</span>

<span class="sd">    :param widths: An array of dimension N x n specifying the widths of all strata in each dimension</span>
<span class="sd">                   Example - A 2D stratification with 2 strata in each dimension</span>
<span class="sd">                   widths = [[0.5, 0.5]</span>
<span class="sd">                             [0.5, 0.5]</span>
<span class="sd">                             [0.5, 0.5]</span>
<span class="sd">                             [0.5, 0.5]]</span>
<span class="sd">    :type widths: numpy array</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :param Strata.weights: An array of dimension 1 x N containing sample weights.</span>
<span class="sd">                    Sample weights are equal to the product of the strata widths (i.e. they are equal to the</span>
<span class="sd">                    size of the strata in the [0, 1]^n space.</span>
<span class="sd">    :type Strata.weights: numpy array</span>

<span class="sd">    **Author:**</span>

<span class="sd">    Michael D. Shields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span> <span class="o">=</span> <span class="n">n_strata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">origins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span>

        <span class="c1"># Read a stratified design from an input file.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The strata are not fully defined. Must provide [n_strata], &#39;</span>
                             <span class="s1">&#39;input file, or [origins] and [widths].&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Read the strata from the specified input file</span>
                <span class="c1"># See documentation for input file formatting</span>
                <span class="n">array_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>

                <span class="c1"># Check to see that the strata are space-filling</span>
                <span class="n">space_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The stratum design is not space-filling.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The stratum design is over-filling.&#39;</span><span class="p">)</span>

        <span class="c1"># Define a rectilinear stratification by specifying the number of strata in each dimension via nstrata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullfact</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fullfact</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a full-factorial design</span>

<span class="sd">        Note: This function has been modified from pyDOE, released under BSD License (3-Clause)</span>
<span class="sd">        Copyright (C) 2012 - 2013 - Michael Baudin</span>
<span class="sd">        Copyright (C) 2012 - Maria Christopoulou</span>
<span class="sd">        Copyright (C) 2010 - 2011 - INRIA - Michael Baudin</span>
<span class="sd">        Copyright (C) 2009 - Yann Collette</span>
<span class="sd">        Copyright (C) 2009 - CEA - Jean-Marc Martinez</span>
<span class="sd">        Original source code can be found at:</span>
<span class="sd">        https://pythonhosted.org/pyDOE/#</span>
<span class="sd">        or</span>
<span class="sd">        https://pypi.org/project/pyDOE/</span>
<span class="sd">        or</span>
<span class="sd">        https://github.com/tisimst/pyDOE/</span>

<span class="sd">        **Input:**</span>

<span class="sd">        :param levels: A list of integers that indicate the number of levels of each input design factor.</span>
<span class="sd">        :type levels: list</span>

<span class="sd">        **Output:**</span>

<span class="sd">        :return ff: Full-factorial design matrix.</span>
<span class="sd">        :rtype ff: ndarray</span>

<span class="sd">        **Author:**</span>

<span class="sd">        Michael D. Shields</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Number of factors</span>
        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="c1"># Number of combinations</span>
        <span class="n">n_comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_comb</span><span class="p">,</span> <span class="n">n_factors</span><span class="p">))</span>

        <span class="n">level_repeat</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">range_repeat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_factors</span><span class="p">):</span>
            <span class="n">range_repeat</span> <span class="o">//=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lvl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lvl</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">level_repeat</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">lvl</span> <span class="o">*</span> <span class="n">range_repeat</span>
            <span class="n">level_repeat</span> <span class="o">*=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ff</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span>

        <span class="k">return</span> <span class="n">ff</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Refined Stratified Sampling (RSS)</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">RSS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate new samples using adaptive sampling methods, i.e. Refined Stratified Sampling and Gradient</span>
<span class="sd">    Enhanced Refined Stratified Sampling.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. Michael D. Shields, Kirubel Teferra, Adam Hapij and Raymond P. Daddazio, &quot;Refined Stratified Sampling for</span>
<span class="sd">       efficient Monte Carlo based uncertainty quantification&quot;, Reliability Engineering &amp; System Safety,</span>
<span class="sd">       ISSN: 0951-8320, Vol: 142, Page: 310-325, 2015.</span>
<span class="sd">    2. M. D. Shields, &quot;Adaptive Monte Carlo analysis for strongly nonlinear stochastic systems&quot;,</span>
<span class="sd">       Reliability Engineering &amp; System Safety, ISSN: 0951-8320, Vol: 175, Page: 207-224, 2018.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param run_model_object: A RunModel object, which is used to evaluate the function value</span>
<span class="sd">    :type run_model_object: class</span>

<span class="sd">    :param sample_object: A SampleMethods class object, which contains information about existing samples</span>
<span class="sd">    :type sample_object: class</span>

<span class="sd">    :param krig_object: A kriging class object, only  required if meta is &#39;Kriging&#39;.</span>
<span class="sd">    :type krig_object: class</span>

<span class="sd">    :param local: Indicator to update surrogate locally.</span>
<span class="sd">    :type local: boolean</span>

<span class="sd">    :param max_train_size: Minimum size of training data around new sample used to update surrogate.</span>
<span class="sd">                           Default: nsamples</span>
<span class="sd">    :type max_train_size: int</span>
<span class="sd">    :param step_size: Step size to calculate the gradient using central difference. Only required if Delaunay is</span>
<span class="sd">                      used as surrogate approximation.</span>
<span class="sd">    :type step_size: float</span>

<span class="sd">    :param n_add: Number of samples generated in each iteration</span>
<span class="sd">    :type n_add: int</span>

<span class="sd">    :param verbose: A boolean declaring whether to write text to the terminal.</span>
<span class="sd">    :type verbose: bool</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :param: RSS.sample_object.samples: Final/expanded samples.</span>
<span class="sd">    :type: RSS.sample_object.samples: ndarray</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Mohit S. Chauhan</span>
<span class="sd">    Last modified: 01/07/2020 by Mohit S. Chauhan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_model_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">step_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Initialize attributes that are common to all approaches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span> <span class="o">=</span> <span class="n">sample_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="o">=</span> <span class="n">run_model_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">stype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># Run Initial Error Checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_rss</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">run_model_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">local</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="o">=</span> <span class="n">max_train_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="o">=</span> <span class="n">krig_object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span> <span class="o">=</span> <span class="n">qoi_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: GE-RSS - Running the initial sample set.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: GE-RSS - A RSS class object has been initiated.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: RSS - A RSS class object has been initiated.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute refined stratified sampling.</span>

<span class="sd">        This is an instance method that runs refined stratified sampling. It is automatically called when the RSS class</span>
<span class="sd">        is instantiated.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param nsamples: Final size of the samples.</span>
<span class="sd">        :type nsamples: int</span>

<span class="sd">        :param n_add: Number of samples to generate with each iteration.</span>
<span class="sd">        :type n_add: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;UQpy Error: The number of requested samples must be larger than the existing &#39;</span>
                                      <span class="s1">&#39;sample set.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_gerss</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_rss</span><span class="p">()</span>

    <span class="c1">###################################################</span>
    <span class="c1"># Run Gradient-Enhanced Refined Stratified Sampling</span>
    <span class="c1">###################################################</span>
    <span class="k">def</span> <span class="nf">run_gerss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples are generated using Gradient Enhanced-Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --------------------------</span>
        <span class="c1"># RECTANGULAR STRATIFICATION</span>
        <span class="c1"># --------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing GE-RSS with rectangular stratification...&#39;</span><span class="p">)</span>

            <span class="c1"># Initialize the training points for the surrogate model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Initialize the vector of gradients at each training point</span>
            <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

                <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
                <span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                        <span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

                <span class="c1"># ---------------------------------------------------</span>
                <span class="c1"># Compute the gradients at the existing sample points</span>
                <span class="c1"># ---------------------------------------------------</span>

                <span class="c1"># Use the entire sample set to train the surrogate model (more expensive option)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">:</span>
                    <span class="n">dy_dx</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">),</span>
                                                       <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">+</span>
                                                       <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">)</span>

                <span class="c1"># Use only max_train_size points to train the surrogate model (more economical option)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Find the nearest neighbors to the most recently added point</span>
                    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
                    <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span><span class="p">)</span>
                    <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">))</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># Recompute the gradient only at the nearest neighbor points.</span>
                    <span class="n">dy_dx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]),</span>
                                                              <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)[</span><span class="n">neighbors</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">+</span>
                                                                         <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span>
                                                                             <span class="n">neighbors</span><span class="p">]))</span>

                <span class="c1"># Define the gradient vector for application of the Delta Method</span>
                <span class="n">dy_dx1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

                <span class="c1"># ------------------------------</span>
                <span class="c1"># Determine the stratum to break</span>
                <span class="c1"># ------------------------------</span>

                <span class="c1"># Estimate the variance within each stratum by assuming a uniform distribution over the stratum.</span>
                <span class="c1"># All input variables are independent</span>
                <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Estimate the variance over the stratum by Delta Method</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy_dx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dy_dx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Break the &#39;p&#39; stratum with the maximum weight</span>
                <span class="n">bin2break</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">bin2break</span><span class="p">))</span>

                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># Cut the stratum in the direction of maximum gradient</span>
                    <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">))</span>
                    <span class="n">dir2break</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dy_dx1</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">]))]</span>

                    <span class="c1"># Divide the stratum bin2break in the direction dir2break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">&lt;</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">/</span><span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                    <span class="c1"># Add a uniform random sample inside the new stratum</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># Adding new sample to training points, samplesU01 and samples attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Run the model at the new sample point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># ----------------------</span>
        <span class="c1"># VORONOI STRATIFICATION</span>
        <span class="c1"># ----------------------</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>

            <span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">compute_Delaunay_centroid_volume</span><span class="p">,</span> <span class="n">voronoi_unit_hypercube</span>
            <span class="kn">from</span> <span class="nn">scipy.spatial.qhull</span> <span class="k">import</span> <span class="n">Delaunay</span>
            <span class="kn">import</span> <span class="nn">math</span>
            <span class="kn">import</span> <span class="nn">itertools</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Extract the boundary vertices and use them in the Delaunay triangulation / mesh generation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="ow">or</span> \
                    <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">])</span>

            <span class="c1"># Define the simplex mesh to be used for gradient estimation and sampling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">furthest_site</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Defining attributes of Delaunay, so that pycharm can check that it exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">:</span> <span class="nb">classmethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span>
            <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>
            <span class="n">dy_dx_old</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

                <span class="c1"># Compute the centroids and the volumes of each simplex cell in the mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">compute_Delaunay_centroid_volume</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
                <span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                        <span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

                <span class="c1"># ---------------------------------------------------</span>
                <span class="c1"># Compute the gradients at the existing sample points</span>
                <span class="c1"># ---------------------------------------------------</span>

                <span class="c1"># Use the entire sample set to train the surrogate model (more expensive option)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">or</span> \
                        <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">:</span>
                    <span class="n">dy_dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">)</span>

                <span class="c1"># Use only max_train_size points to train the surrogate model (more economical option)</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># Build a mapping from the new vertex indices to the old vertex indices.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Find the nearest neighbors to the most recently added point</span>
                    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
                    <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span><span class="p">)</span>
                    <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">))</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                               <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># For every simplex, check if at least dimension-1 vertices are in the neighbor set.</span>
                    <span class="c1"># Only update the gradient in simplices that meet this criterion.</span>
                    <span class="n">update_list</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">18</span>
                        <span class="n">v_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)</span>
                        <span class="n">v_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_list</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">18</span><span class="p">)]))):</span>
                                <span class="n">update_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                    <span class="n">update_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">update_list</span><span class="p">)</span>

                    <span class="c1"># Initialize the gradient vector</span>
                    <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>

                    <span class="c1"># For those simplices that will not be updated, use the previous gradient</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dy_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dy_dx_old</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]</span>

                    <span class="c1"># For those simplices that will be updated, compute the new gradient</span>
                    <span class="n">dy_dx</span><span class="p">[</span><span class="n">update_array</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)[</span><span class="n">neighbors</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">update_array</span><span class="p">])</span>

                <span class="c1"># ----------------------------------------------------</span>
                <span class="c1"># Determine the simplex to break and draw a new sample</span>
                <span class="c1"># ----------------------------------------------------</span>

                <span class="c1"># Estimate the variance over each simplex by Delta Method. Moments of the simplices are computed using</span>
                <span class="c1"># Eq. (19) from the following reference:</span>
                <span class="c1"># Good, I.J. and Gaskins, R.A. (1971). The Centroid Method of Numerical Integration. Numerische</span>
                <span class="c1">#       Mathematik. 16: 343--359.</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]][:,</span> <span class="n">k</span><span class="p">])</span>
                        <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">/</span>
                                     <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">dy_dx_old</span> <span class="o">=</span> <span class="n">dy_dx</span>

                <span class="c1"># Identify the stratum with the maximum weight</span>
                <span class="n">bin2add</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>

                <span class="c1"># Create &#39;p&#39; sub-simplex within the simplex with maximum variance</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># Create a sub-simplex within the simplex with maximum variance.</span>
                    <span class="n">tmp_vertices</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bin2add</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]]</span>
                    <span class="n">col_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">)</span>  <span class="c1"># node: an array containing mid-point of edges</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">[</span><span class="n">col_one</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

                    <span class="c1"># Using the Simplex class to generate a new sample in the sub-simplex</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

                <span class="c1"># Update the matrices to have recognize the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">p</span><span class="p">)])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>

                <span class="c1"># Update the Delaunay triangulation mesh to include the new point.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>

                <span class="c1"># Update the sample arrays to include the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Identify the new point in the parameter space and update the sample array to include the new point.</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Run the mode at the new point.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">new_point</span><span class="p">)</span>

                <span class="c1"># Compute the strata weights.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1">#################################</span>
    <span class="c1"># Run Refined Stratified Sampling</span>
    <span class="c1">#################################</span>
    <span class="k">def</span> <span class="nf">run_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples are generated using Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --------------------------</span>
        <span class="c1"># RECTANGULAR STRATIFICATION</span>
        <span class="c1"># --------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing RSS with rectangular stratification...&#39;</span><span class="p">)</span>

            <span class="c1"># Initialize the training points for the surrogate model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>
                <span class="c1"># ------------------------------</span>
                <span class="c1"># Determine the stratum to break</span>
                <span class="c1"># ------------------------------</span>
                <span class="c1"># Estimate the weight corresponding to each stratum</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Break the &#39;p&#39; stratum with the maximum weight</span>
                <span class="n">bin2break</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">bin2break</span><span class="p">))</span>

                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># Cut the stratum in the direction of maximum length</span>
                    <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">dir2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># Divide the stratum bin2break in the direction dir2break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">&lt;</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">/</span><span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                    <span class="c1"># Add a uniform random sample inside the new stratum</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># Adding new sample to training points, samplesU01 and samples attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># ----------------------</span>
        <span class="c1"># VORONOI STRATIFICATION</span>
        <span class="c1"># ----------------------</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>

            <span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">compute_Delaunay_centroid_volume</span><span class="p">,</span> <span class="n">voronoi_unit_hypercube</span>
            <span class="kn">from</span> <span class="nn">scipy.spatial.qhull</span> <span class="k">import</span> <span class="n">Delaunay</span>
            <span class="kn">import</span> <span class="nn">math</span>
            <span class="kn">import</span> <span class="nn">itertools</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Extract the boundary vertices and use them in the Delaunay triangulation / mesh generation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="ow">or</span> \
                        <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="p">])</span>

            <span class="c1"># Define the simplex mesh to be used for sampling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">furthest_site</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Defining attributes of Delaunay, so that pycharm can check that it exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">:</span> <span class="nb">classmethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span>
            <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

                <span class="c1"># Compute the centroids and the volumes of each simplex cell in the mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">compute_Delaunay_centroid_volume</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                <span class="c1"># ----------------------------------------------------</span>
                <span class="c1"># Determine the simplex to break and draw a new sample</span>
                <span class="c1"># ----------------------------------------------------</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Identify the stratum with the maximum weight</span>
                <span class="n">bin2add</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>

                <span class="c1"># Create &#39;p&#39; sub-simplex within the simplex with maximum weight</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="n">tmp_vertices</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bin2add</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]]</span>
                    <span class="n">col_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                        <span class="n">tmp_vertices</span><span class="p">)</span>  <span class="c1"># node: an array containing mid-point of edges</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">[</span><span class="n">col_one</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

                    <span class="c1"># Using the Simplex class to generate a new sample in the sub-simplex</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

                <span class="c1"># Update the matrices to have recognize the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">p</span><span class="p">)])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>

                <span class="c1"># Update the Delaunay triangulation mesh to include the new point.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>

                <span class="c1"># Update the sample arrays to include the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Identify the new point in the parameter space and update the sample array to include the new point.</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Compute the strata weights.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># Support functions for RSS and GE-RSS</span>

    <span class="k">def</span> <span class="nf">estimate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimating gradients with a metamodel (surrogate).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param x: Samples in the training data.</span>
<span class="sd">        :type x: numpy array</span>

<span class="sd">        :param y: Function values evaluated at the samples in the training data.</span>
<span class="sd">        :type y: numpy array</span>

<span class="sd">        :param xt: Samples where gradients are computed.</span>
<span class="sd">        :type xt: numpy array</span>

<span class="sd">        **Outputs:**</span>
<span class="sd">        :return gr: First-order gradient evaluated at the points &#39;xt&#39;.</span>
<span class="sd">        :rtype gr: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">UQpy.Reliability</span> <span class="k">import</span> <span class="n">TaylorSeries</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Krig&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;GaussianProcessRegressor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">predict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">LinearNDInterpolator</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span>

        <span class="n">gr</span> <span class="o">=</span> <span class="n">TaylorSeries</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">xt</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">tck</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span>
                                   <span class="n">df_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gr</span>

    <span class="k">def</span> <span class="nf">init_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;STS&#39;</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: sample_object must be an object of the STS or RSS class.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RunModel&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: run_model_object must be an object of the RunModel class.&quot;</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                        Generating random samples inside a Simplex</span>
<span class="c1">########################################################################################################################</span>

<span class="k">class</span> <span class="nc">Simplex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random samples inside a simplex using uniform probability distribution.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. W. N. Edelinga, R. P. Dwightb, P. Cinnellaa, &quot;Simplex-stochastic collocation method with improved</span>
<span class="sd">       calability&quot;,Journal of Computational Physics, 310:301328 2016.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param nodes: The vertices of the simplex</span>
<span class="sd">    :type nodes: ndarray</span>

<span class="sd">    :param nsamples: The number of samples to be generated inside the simplex</span>
<span class="sd">    :type nsamples: int</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :return Simplex.samples: New random samples distributed uniformly inside the simplex.</span>
<span class="sd">    :rtype Simplex.samples: ndarray</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Dimitris G.Giovanis</span>
<span class="sd">    Last modified: 11/28/2018 by Mohit S. Chauhan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Dimitris G.Giovanis</span>
    <span class="c1"># Last modified: 11/28/2018 by Mohit S. Chauhan</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_sis</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates uniformly distributed random samples inside the simplex.</span>

<span class="sd">        This is an instance method that generates samples. It is automatically called when the Simplex class is</span>
<span class="sd">        instantiated.</span>

<span class="sd">        **Output:**</span>

<span class="sd">        :return sample: Random samples</span>
<span class="sd">        :rtype sample: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dimension</span><span class="p">])</span>
                <span class="n">ad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">b_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                        <span class="n">ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="n">b_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="n">ad</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">b_</span><span class="p">))</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">r_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">init_sis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Number of samples to be generated &#39;nsamples&#39; should be a positive &quot;</span>
                                      <span class="s2">&quot;integer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Size of simplex (nodes) is not consistent.&quot;</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                  Adaptive Kriging-Monte Carlo Simulation (AK-MCS)</span>
<span class="c1">########################################################################################################################</span>
<span class="k">class</span> <span class="nc">AKMCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate new samples using different active learning method and properties of kriging surrogate along with</span>
<span class="sd">    MCS.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. B. Echard, N. Gayton and M. Lemaire, &quot;AK-MCS: An active learning reliability method combining Kriging and</span>
<span class="sd">        Monte Carlo Simulation&quot;, Structural Safety, Pages 145-154, 2011.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param run_model_object: A RunModel object, which is used to evaluate the function value</span>
<span class="sd">    :type run_model_object: class</span>

<span class="sd">    :param samples: A 2d-array of samples</span>
<span class="sd">    :type samples: ndarray</span>

<span class="sd">    :param krig_object: A kriging class object</span>
<span class="sd">    :type krig_object: class</span>

<span class="sd">    :param population: Sample which are used as learning set by AKMCS class.</span>
<span class="sd">    :type population: ndarray</span>

<span class="sd">    :param nlearn: Number of sample generated using MCS, which are used as learning set by AKMCS. Only required</span>
<span class="sd">                   if population is not defined.</span>
<span class="sd">    :type nlearn: int</span>

<span class="sd">    :param nstart: Number of initial samples generated using LHS. Only required if sample_object is not defined.</span>
<span class="sd">    :type nstart: int</span>

<span class="sd">    :param dist_name: A list containing the names of the distributions of the random variables. This is only</span>
<span class="sd">                      required if sample_object is not defined.</span>
<span class="sd">                      Distribution names must match those in the Distributions module.</span>
<span class="sd">                      If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                      provide custom_dist.py.</span>
<span class="sd">                      The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                      dimension.</span>
<span class="sd">    :type dist_name: string list</span>

<span class="sd">    :param dist_params: Parameters of the distribution</span>
<span class="sd">                        Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                        Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                        distribution, dist[i].</span>
<span class="sd">    :type dist_params: list</span>

<span class="sd">    :param lf: Learning function used as selection criteria to identify the new samples.</span>
<span class="sd">               Options: U, Weighted-U, EFF, EIF and EGIF</span>
<span class="sd">    :type lf: str/function</span>

<span class="sd">    :param n_add: Number of samples to be selected per iteration.</span>
<span class="sd">    :type n_add: int</span>

<span class="sd">    :param min_cov: Minimum Covariance used as the stopping criteria of AKMCS method in case of reliability</span>
<span class="sd">                    analysis.</span>
<span class="sd">    :type min_cov: float</span>

<span class="sd">    :param max_p: Maximum possible value of probability density function of samples. Only required with</span>
<span class="sd">                  &#39;Weighted-U&#39; learning function.</span>
<span class="sd">    :type max_p: float</span>

<span class="sd">    :param save_pf: Indicator to estimate probability of failure after each iteration. Only required if</span>
<span class="sd">                    user-defined learning function is used.</span>
<span class="sd">    :type save_pf: boolean</span>

<span class="sd">    :param verbose: A boolean declaring whether to write text to the terminal.</span>
<span class="sd">    :type verbose: bool</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :param: AKMCS.sample_object.samples: Final/expanded samples.</span>
<span class="sd">    :type: AKMCS..sample_object.samples: ndarray</span>

<span class="sd">    :param: AKMCS.krig_model: Prediction function for the final surrogate model.</span>
<span class="sd">    :type: AKMCS.krig_model: function</span>

<span class="sd">    :param: AKMCS.pf: Probability of failure after every iteration of AKMCS. Available as an output only for</span>
<span class="sd">                       Reliability Analysis.</span>
<span class="sd">    :type: AKMCS.pf: float list</span>

<span class="sd">    :param: AKMCS.cov_pf: Covariance of probability of failure after every iteration of AKMCS. Available as an</span>
<span class="sd">                           output only for Reliability Analysis.</span>
<span class="sd">    :type: AKMCS.pf: float list</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Mohit S. Chauhan</span>
<span class="sd">    Last modified: 01/07/2020 by Mohit S. Chauhan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_model_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nlearn</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">nstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lf</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">min_cov</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">max_p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kriging</span><span class="o">=</span><span class="s1">&#39;UQpy&#39;</span><span class="p">,</span> <span class="n">save_pf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Initialize the internal variables of the class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="o">=</span> <span class="n">run_model_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="o">=</span> <span class="n">krig_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlearn</span> <span class="o">=</span> <span class="n">nlearn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstart</span> <span class="o">=</span> <span class="n">nstart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span> <span class="o">=</span> <span class="n">qoi_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cov</span> <span class="o">=</span> <span class="n">min_cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_p</span> <span class="o">=</span> <span class="n">max_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">population</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">=</span> <span class="n">kriging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="o">=</span> <span class="n">save_pf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize and run preliminary error checks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_akmcs</span><span class="p">()</span>

        <span class="c1"># Run AKMCS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_akmcs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_akmcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes Adaptive Kriging - Monte Carlo Method.</span>

<span class="sd">        This is an instance method that check initial sample design an evaluate model at the training points. It is</span>
<span class="sd">        automatically called when the STS class is instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the initial sample design does not exists, run the initial calculations.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Generating the initial sample set using Latin hypercube sampling.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nstart</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Running the initial sample set using RunModel.&#39;</span><span class="p">)</span>

        <span class="c1"># Evaluate model at the training points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterative procedure is applied to learn samples based on metamodel and learning function, and then metamodel is</span>
<span class="sd">        updated based on new samples.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param samples: A 2d-array of samples</span>
<span class="sd">        :type samples: ndarray</span>

<span class="sd">        :param n_add: Number of samples to be selected per iteration.</span>
<span class="sd">        :type n_add: int</span>

<span class="sd">        :param append_samples: If &#39;True&#39;, new samples are append to existing samples in sample_object. Otherwise,</span>
<span class="sd">                               existing samples are discarded.</span>
<span class="sd">        :type append_samples: boolean</span>

<span class="sd">        :param nsamples: Number of samples to generate. No Default Value: nsamples must be prescribed.</span>
<span class="sd">        :type nsamples: int</span>

<span class="sd">        :param lf: Learning function used as selection criteria to identify the new samples. Only required, if</span>
<span class="sd">                   samples are generated using multiple criterion</span>
<span class="sd">                   Options: U, Weighted-U, EFF, EIF and EGIF</span>
<span class="sd">        :type lf: str/function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">!=</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">if</span> <span class="n">n_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="k">if</span> <span class="n">lf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># New samples are appended to existing samples, if append_samples is TRUE</span>
            <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">samples</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Running the provided sample set using RunModel.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="n">append_samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing AK-MCS design...&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the population of samples at which to evaluate the learning function and from which to draw in the</span>
        <span class="c1"># sampling.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">MCS</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span>
                                  <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nlearn</span><span class="p">)</span>

        <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

        <span class="c1"># Train the initial Kriging model.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">interpolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

        <span class="c1"># ---------------------------------------------</span>
        <span class="c1"># Primary loop for learning and adding samples.</span>
        <span class="c1"># ---------------------------------------------</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
            <span class="c1"># Find all of the points in the population that have not already been integrated into the training set</span>
            <span class="n">rest_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>

            <span class="c1"># Apply the learning function to identify the new point to run the model.</span>

            <span class="n">new_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">)</span>
            <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">rest_pop</span><span class="p">[</span><span class="n">new_ind</span><span class="p">])</span>

            <span class="c1"># Add the new points to the training set and to the sample set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

            <span class="c1"># Run the model at the new points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">))</span>

            <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

            <span class="c1"># Retrain the Kriging surrogate model</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>
                    <span class="c1"># disable printing output comments</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">interpolate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">rest_pop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">rest_pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">n_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
                <span class="n">pf</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pf</span> <span class="o">*</span> <span class="n">n_</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS complete&#39;</span><span class="p">)</span>

    <span class="c1"># ------------------</span>
    <span class="c1"># LEARNING FUNCTIONS</span>
    <span class="c1"># ------------------</span>
    <span class="k">def</span> <span class="nf">eigf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Expected Improvement for Global Fit (EIGF) as learning function</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. J.N Fuhg, &quot;Adaptive surrogate models for parametric studies&quot;, Master&#39;s Thesis</span>
<span class="sd">           (Link: https://arxiv.org/pdf/1905.05345.pdf)</span>

<span class="sd">        **Inputs:**</span>
<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="c1"># Evaluation of the learning function</span>
        <span class="c1"># First, find the nearest neighbor in the training set for each point in the population.</span>
        <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">))</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">qoi_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])</span>

        <span class="c1"># Compute the learning function at every point in the population.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">qoi_array</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on U-function as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. B. Echard, N. Gayton and M. Lemaire, &quot;AK-MCS: An active learning reliability method combining Kriging and</span>
<span class="sd">        Monte Carlo Simulation&quot;, Structural Safety, Pages 145-154, 2011.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">weighted_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Probability Weighted U-function as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. V.S. Sundar and M.S. Shields, &quot;RELIABILITY ANALYSIS USING ADAPTIVE KRIGING SURROGATES WITH MULTIMODEL</span>
<span class="sd">           INFERENCE&quot;.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">p2</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">p1</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">p2</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_p</span><span class="p">)</span>
        <span class="c1"># u_ = u * p1/max(p1)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Expected Feasibilty Function (EFF) as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. B.J. Bichon, M.S. Eldred, L.P.Swiler, S. Mahadevan, J.M. McFarland, &quot;Efficient Global Reliability Analysis</span>
<span class="sd">           for Nonlinear Implicit Performance Functions&quot;, AIAA JOURNAL, Volume 46, 2008.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="c1"># Reliability threshold: a_ = 0</span>
        <span class="c1"># EGRA method: epshilon = 2*sigma(x)</span>
        <span class="n">a_</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sig</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">+</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">eff</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">a_</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="o">-</span><span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="n">ep</span> <span class="o">*</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">:]</span>

        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">n_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">pf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">iin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">iin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pf</span> <span class="o">*</span> <span class="n">n_</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">eif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Expected Improvement Function (EIF) as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. D.R. Jones, M. Schonlau, W.J. Welch, &quot;Efficient Global Optimization of Expensive Black-Box Functions&quot;,</span>
<span class="sd">           Journal of Global Optimization, Pages 455492, 1998.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="n">fm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="o">+</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="k">def</span> <span class="nf">learning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines the leaning function used to generate new samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">,</span> <span class="s1">&#39;EIF&#39;</span><span class="p">,</span> <span class="s1">&#39;EIGF&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: The provided learning function is not recognized.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EIGF&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigf</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EIF&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eif</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff</span>

    <span class="k">def</span> <span class="nf">init_akmcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS requires a predefined RunModel object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">learning</span><span class="p">()</span>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Markov Chain Monte Carlo</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCMC"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC">[docs]</a><span class="k">class</span> <span class="nc">MCMC</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate samples from arbitrary user-specified probability density function using Markov Chain Monte Carlo.</span>

<span class="sd">    This is the parent class for all MCMC algorithms. This parent class only provides the framework for MCMC and cannot</span>
<span class="sd">    be used directly for sampling. Sampling is done by calling the child class for the specific MCMC algorithm.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **dimension** (`int`):</span>
<span class="sd">        A scalar value defining the dimension of target density function. Either `dimension` and `nchains` or `seed`</span>
<span class="sd">        must be provided.</span>

<span class="sd">    * **pdf_target** ((`list` of) callables):</span>
<span class="sd">        Target density function from which to draw random samples. Either `pdf_target` or `log_pdf_target` must be</span>
<span class="sd">        provided (the latter should be preferred for better numerical stability).</span>

<span class="sd">        If `pdf_target` is a callable, it refers to the joint pdf to sample from, it must take at least one input `x`,</span>
<span class="sd">        which are the point(s) at which to evaluate the pdf. Within MCMC the `pdf_target` is evaluated as:</span>
<span class="sd">        ``p(x) = pdf_target(x, *args_target)``</span>

<span class="sd">        where `x` is a ndarray of shape (nsamples, dimension) and `args_target` are additional positional arguments that</span>
<span class="sd">        are provided to MCMC via its `args_target` input.</span>

<span class="sd">        If `pdf_target` is a list of callables, it refers to independent marginals to sample from. The marginal in</span>
<span class="sd">        dimension `j` is evaluated as: ``p_j(xj) = pdf_target[j](xj, *args_target[j])`` where `x` is a ndarray of shape</span>
<span class="sd">        (nsamples, dimension)</span>

<span class="sd">    * **log_pdf_target** ((`list` of) callables):</span>
<span class="sd">        Logarithm of the target density function from which to draw random samples. Either `pdf_target` or</span>
<span class="sd">        `log_pdf_target` must be provided (the latter should be preferred for better numerical stability).</span>

<span class="sd">        Same comments as for input `pdf_target`.</span>

<span class="sd">    * **args_target** ((`list` of) `tuple`):</span>
<span class="sd">        Positional arguments of the pdf / log-pdf target function. See `pdf_target`</span>

<span class="sd">    * **seed** (`ndarray`):</span>
<span class="sd">        Seed of the Markov chain(s), shape ``(nchains, dimension)``. Default: zeros(`nchains` x `dimension`).</span>

<span class="sd">        If `seed` is not provided, both `nchains` and `dimension` must be provided.</span>

<span class="sd">    * **nburn** (`int`):</span>
<span class="sd">        Length of burn-in - i.e., number of samples at the beginning of the chain to discard (note: no thinning during</span>
<span class="sd">        burn-in). Default is 0, no burn-in.</span>

<span class="sd">    * **jump** (`int`):</span>
<span class="sd">        Thinning parameter, used to reduce correlation between samples. Setting `jump=n` corresponds to	skipping `n-1`</span>
<span class="sd">        states between accepted states of the chain. Default is 1 (no thinning).</span>

<span class="sd">    * **nchains** (`int`):</span>
<span class="sd">        The number of Markov chains to generate. Either `dimension` and `nchains` or `seed` must be provided.</span>

<span class="sd">    * **save_log_pdf** (`bool`):</span>
<span class="sd">        Boolean that indicates whether to save log-pdf values along with the samples. Default: False</span>

<span class="sd">    * **verbose** (`boolean`)</span>
<span class="sd">        Set ``verbose = True`` to print status messages to the terminal during execution.</span>

<span class="sd">    * **concat_chains** (`bool`):</span>
<span class="sd">        Boolean that indicates whether to concatenate the chains after a run, i.e., samples are stored as an `ndarray`</span>
<span class="sd">        of shape (nsamples * nchains, dimension) if True, (nsamples, nchains, dimension) if False. Default: True</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`)</span>
<span class="sd">        Set of MCMC samples following the target distribution, `ndarray` of shape (`nsamples` * `nchains`, `dimension`)</span>
<span class="sd">        or (nsamples, nchains, dimension) (see input `concat_chains`).</span>

<span class="sd">    * **log_pdf_values** (`ndarray`)</span>
<span class="sd">        Values of the log pdf for the accepted samples, `ndarray` of shape (nchains * nsamples,) or (nsamples, nchains)</span>

<span class="sd">    * **nsamples** (`list`)</span>
<span class="sd">        Total number of samples; The `nsamples` attribute tallies the total number of generated samples. After each</span>
<span class="sd">        iteration, it is updated by 1. At the end of the simulation, the `nsamples` attribute equals the user-specified</span>
<span class="sd">        value for input `nsamples` given to the child class.</span>

<span class="sd">    * **nsamples_per_chain** (`list`)</span>
<span class="sd">        Total number of samples per chain; Similar to the attribute `nsamples`, it is updated during iterations as new</span>
<span class="sd">        samples are saved.</span>

<span class="sd">    * **niterations** (`list`)</span>
<span class="sd">        Total number of iterations, updated on-the-fly as the algorithm proceeds. It is related to number of samples as</span>
<span class="sd">        niterations=nburn+jump*nsamples_per_chain.</span>

<span class="sd">    * **acceptance_rate** (`list`)</span>
<span class="sd">        Acceptance ratio of the MCMC chains, computed separately for each chain.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Last Modified: 10/05/20 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nburn</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nburn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nburn should be an integer &gt;= 0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">jump</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">jump</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: jump should be an integer &gt;= 1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Check target pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_target</span><span class="p">(</span>
            <span class="n">pdf</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args_target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span> <span class="o">=</span> <span class="n">save_log_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat_chains</span> <span class="o">=</span> <span class="n">concat_chains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">log_pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="o">=</span> <span class="n">pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_target</span> <span class="o">=</span> <span class="n">args_target</span>

        <span class="c1"># Initialize a few more variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total nb of iterations, grows if you call run several times</span>

<div class="viewcode-block" id="MCMC.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the MCMC algorithm.</span>

<span class="sd">        This function samples from the MCMC chains and appends samples to existing ones (if any). This method leverages</span>
<span class="sd">        the ``run_iterations`` method that is specific to each algorithm.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to generate.</span>

<span class="sd">        * **nsamples_per_chain** (`int`)</span>
<span class="sd">            Number of samples to generate per chain.</span>

<span class="sd">        Either `nsamples` or `nsamples_per_chain` must be provided (not both). Not that if `nsamples` is not a multiple</span>
<span class="sd">        of `nchains`, `nsamples` is set to the next largest integer that is a multiple of `nchains`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the runs: allocate space for the new samples and log pdf values</span>
        <span class="n">final_nsamples</span><span class="p">,</span> <span class="n">final_nsamples_per_chain</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_samples</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running MCMC...&#39;</span><span class="p">)</span>

        <span class="c1"># Run nsims iterations of the MCMC algorithm, starting at current_state</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">&lt;</span> <span class="n">final_nsamples_per_chain</span><span class="p">:</span>
            <span class="c1"># update the total number of iterations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># run iteration</span>
            <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_one_iteration</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)</span>
            <span class="c1"># Update the chain, only if burn-in is over and the sample is not being jumped over</span>
            <span class="c1"># also increase the current number of samples and samples_per_chain</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_log_pdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: MCMC run successfully !&#39;</span><span class="p">)</span>

        <span class="c1"># Concatenate chains maybe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat_chains</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate_chains</span><span class="p">()</span></div>

<div class="viewcode-block" id="MCMC.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC algorithm, starting at `current_state`.</span>

<span class="sd">        This method is over-written for each different MCMC algorithm. It must return the new state and associated</span>
<span class="sd">        log-pdf, which will be passed as inputs to the ``run_one_iteration`` method at the next iteration.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **current_state** (`ndarray`):</span>
<span class="sd">            Current state of the chain(s), `ndarray` of shape ``(nchains, dimension)``.</span>

<span class="sd">        * **current_log_pdf** (`ndarray`):</span>
<span class="sd">            Log-pdf of the current state of the chain(s), `ndarray` of shape ``(nchains, )``.</span>

<span class="sd">        **Outputs/Returns:**</span>

<span class="sd">        * **new_state** (`ndarray`):</span>
<span class="sd">            New state of the chain(s), `ndarray` of shape ``(nchains, dimension)``.</span>

<span class="sd">        * **new_log_pdf** (`ndarray`):</span>
<span class="sd">            Log-pdf of the new state of the chain(s), `ndarray` of shape ``(nchains, )``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Helper functions that can be used by all algorithms</span>
    <span class="c1"># Methods update_samples, update_accept_ratio and sample_candidate_from_proposal can be called in the run stage.</span>
    <span class="c1"># Methods preprocess_target, preprocess_proposal, check_seed and check_integers can be called in the init stage.</span>

    <span class="k">def</span> <span class="nf">_concatenate_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate chains.</span>

<span class="sd">        Utility function that reshapes (in place) attribute samples from (nsamples, nchains, dimension) to</span>
<span class="sd">        (nsamples * nchains, dimension), and log_pdf_values from (nsamples, nchains) to (nsamples * nchains, ).</span>

<span class="sd">        No input / output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_unconcatenate_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of concatenate_chains.</span>

<span class="sd">        Utility function that reshapes (in place) attribute samples from (nsamples * nchains, dimension) to</span>
<span class="sd">        (nsamples, nchains, dimension), and log_pdf_values from (nsamples * nchains) to (nsamples, nchains).</span>

<span class="sd">        No input / output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize necessary attributes and variables before running the chain forward.</span>

<span class="sd">        Utility function that allocates space for samples and log likelihood values, initialize sample_index,</span>
<span class="sd">        acceptance ratio. If some samples already exist, allocate space to append new samples to the old ones. Computes</span>
<span class="sd">        the number of forward iterations nsims to be run (depending on burnin and jump parameters).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * nchains (int): number of chains run in parallel</span>
<span class="sd">        * nsamples (int): number of samples to be generated</span>
<span class="sd">        * nsamples_per_chain (int): number of samples to be generated per chain</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * nsims (int): Number of iterations to perform</span>
<span class="sd">        * current_state (ndarray of shape (nchains, dim)): Current state of the chain to start from.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either nsamples or nsamples_per_chain must be provided (not both)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples_per_chain</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples_per_chain must be an integer &gt;= 0.&#39;</span><span class="p">)</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples must be an integer &gt;= 0.&#39;</span><span class="p">)</span>
            <span class="n">nsamples_per_chain</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>    <span class="c1"># very first call of run, set current_state as the seed and initialize self.samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>    <span class="c1"># if nburn is 0, save the seed, run one iteration less </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_log_pdf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>

        <span class="k">else</span><span class="p">:</span>    <span class="c1"># fetch previous samples to start the new run, current state is last saved sample</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>   <span class="c1"># the chains were previously concatenated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unconcatenate_chains</span><span class="p">()</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span>

    <span class="k">def</span> <span class="nf">_update_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_accept</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update acceptance rate of the chains.</span>

<span class="sd">        Utility function, uses an iterative function to update the acceptance rate of all the chains separately.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * new_accept (list (length nchains) of bool): indicates whether the current state was accepted (for each chain</span>
<span class="sd">          separately).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span> <span class="o">=</span> <span class="p">[</span><span class="n">na</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">*</span> <span class="n">a</span>
                                <span class="k">for</span> <span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_accept</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess the target pdf inputs.</span>

<span class="sd">        Utility function (static method), that transforms the log_pdf, pdf, args inputs into a function that evaluates</span>
<span class="sd">        log_pdf_target(x) for a given x. If the target is given as a list of callables (marginal pdfs), the list of</span>
<span class="sd">        log margianals is also returned.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * log_pdf ((list of) callables): Log of the target density function from which to draw random samples. Either</span>
<span class="sd">          pdf_target or log_pdf_target must be provided.</span>
<span class="sd">        * pdf ((list of) callables): Target density function from which to draw random samples. Either pdf_target or</span>
<span class="sd">          log_pdf_target must be provided.</span>
<span class="sd">        * args (tuple): Positional arguments of the pdf target.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * evaluate_log_pdf (callable): Callable that computes the log of the target density function</span>
<span class="sd">        * evaluate_log_pdf_marginals (list of callables): List of callables to compute the log pdf of the marginals</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log_pdf is provided</span>
        <span class="k">if</span> <span class="n">log_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">log_pdf</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: When log_pdf_target is a list, args should be a list (of tuples) of same &#39;</span>
                                     <span class="s1">&#39;length.&#39;</span><span class="p">)</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">))))</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">log_pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">))]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target must be a callable or list of callables&#39;</span><span class="p">)</span>
        <span class="c1"># pdf is provided</span>
        <span class="k">elif</span> <span class="n">pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))))</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pdf</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: When pdf_target is given as a list, args should also be a list of same &#39;</span>
                                     <span class="s1">&#39;length.&#39;</span><span class="p">)</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                              <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))),</span>
                        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">))</span>
                        <span class="p">))</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">))]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: pdf_target must be a callable or list of callables&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target or pdf_target should be provided.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evaluate_log_pdf</span><span class="p">,</span> <span class="n">evaluate_log_pdf_marginals</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">nchains</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess input seed.</span>

<span class="sd">        Utility function (static method), that checks the dimension of seed, assign [0., 0., ..., 0.] if not provided.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * seed (ndarray): seed for MCMC</span>
<span class="sd">        * dim (int): dimension of target density</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * seed (ndarray): seed for MCMC</span>
<span class="sd">        * dim (int): dimension of target density</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nchains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either `seed` or `dimension` and `nchains` must be provided.&#39;</span><span class="p">)</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchains</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input seed should be an array of shape (dimension, ) or (nchains, dimension).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Wrong dimensions between seed and dimension.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nchains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nchains</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: The number of chains and the seed shape are inconsistent.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seed</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_methods_proposal</span><span class="p">(</span><span class="n">proposal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if proposal has required methods.</span>

<span class="sd">        Utility function (static method), that checks that the given proposal distribution has 1) a rvs method and 2) a</span>
<span class="sd">        log pdf or pdf method. If a pdf method exists but no log_pdf, the log_pdf methods is added to the proposal</span>
<span class="sd">        object. Used in the MH and MMH initializations.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * proposal (Distribution object): proposal distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal should be a Distribution object&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have an rvs method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have a log_pdf or pdf method&#39;</span><span class="p">)</span>
            <span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">proposal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span></div>


<span class="c1">#################################################################################################################</span>


<div class="viewcode-block" id="MH"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MH">[docs]</a><span class="k">class</span> <span class="nc">MH</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings algorithm</span>

<span class="sd">    **References**</span>

<span class="sd">    1. Gelman et al., &quot;Bayesian data analysis&quot;, Chapman and Hall/CRC, 2013</span>
<span class="sd">    2. R.C. Smith, &quot;Uncertainty Quantification - Theory, Implementation and Applications&quot;, CS&amp;E, 2014</span>


<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **proposal** (``Distribution`` object):</span>
<span class="sd">        Proposal distribution, must have a log_pdf/pdf and rvs method. Default: standard multivariate normal</span>

<span class="sd">    * **proposal_is_symmetric** (`bool`):</span>
<span class="sd">        Indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha</span>
<span class="sd">        Default: False, set to True if default proposal is used</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal_is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Initialize algorithm specific inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="n">proposal_is_symmetric</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either input proposal or dimension must be provided.&#39;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">JointInd</span><span class="p">,</span> <span class="n">Normal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">JointInd</span><span class="p">([</span><span class="n">Normal</span><span class="p">()]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="MH.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MH.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for MH algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sample candidate</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">current_state</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Compute log_pdf_target of candidate sample</span>
        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># Compute acceptance ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">:</span>  <span class="c1"># proposal is symmetric</span>
            <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
            <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidate</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">)</span> <span class="o">-</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">current_state</span> <span class="o">-</span> <span class="n">candidate</span><span class="p">)</span>
            <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>

        <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate (loop over nc chains)</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,))</span>  <span class="c1"># this vector will be used to compute accept_ratio of each chain</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r_</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div></div>


<span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="MMH"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MMH">[docs]</a><span class="k">class</span> <span class="nc">MMH</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Component-wise Modified Metropolis-Hastings algorithm.</span>

<span class="sd">    In this algorithm, candidate samples are drawn separately in each dimension, thus the proposal consists of a list</span>
<span class="sd">    of 1d distributions. The target pdf can be given as a joint pdf or a list of marginal pdfs in all dimensions. This</span>
<span class="sd">    will trigger two different algorithms.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. S.-K. Au and J. L. Beck,Estimation of small failure probabilities in high dimensions by subset simulation,</span>
<span class="sd">       Probabilistic Eng. Mech., vol. 16, no. 4, pp. 263277, Oct. 2001.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **proposal** ((`list` of) ``Distribution`` object(s)):</span>
<span class="sd">        Proposal distribution(s) in one dimension, must have a log_pdf/pdf and rvs method.</span>

<span class="sd">        The proposal object may be a list of ``DistributionContinuous1D`` objects or a ``JointInd`` object.</span>
<span class="sd">        Default: standard normal</span>

<span class="sd">    * **proposal_is_symmetric** ((`list` of) `bool`):</span>
<span class="sd">        Indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha</span>
<span class="sd">        Default: False, set to True if default proposal is used</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal_is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># If proposal is not provided: set it as a list of standard gaussians</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">Normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="n">proposal_is_symmetric</span>

        <span class="c1"># set default proposal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="n">Normal</span><span class="p">(),</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="c1"># Proposal is provided, check it</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only one Distribution is provided, check it and transform it to a list</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># a list of proposals is provided</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal given as a list should be of length dimension&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span>

        <span class="c1"># check the symmetry of proposal, assign False as default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal_is_symmetric should be a (list of) boolean(s)&#39;</span><span class="p">)</span>

        <span class="c1"># check with algo type is used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="s1">&#39;marginals&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="s1">&#39;joint&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="MMH.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MMH.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for MMH algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The target pdf is provided via its marginals</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;marginals&#39;</span><span class="p">:</span>
            <span class="c1"># Evaluate the current log_pdf</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                                                  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)]</span>

            <span class="c1"># Sample candidate (independently in each dimension)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">candidate_j</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

                <span class="c1"># Compute log_pdf_target of candidate sample</span>
                <span class="n">log_p_candidate_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">candidate_j</span><span class="p">)</span>

                <span class="c1"># Compute acceptance ratio</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># proposal is symmetric</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
                    <span class="n">log_prop_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span>
                    <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="n">log_prop_j</span><span class="p">(</span><span class="n">candidate_j</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">-</span> \
                                         <span class="n">log_prop_j</span><span class="p">(</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">candidate_j</span><span class="p">)</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>

                <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate</span>
                <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
                <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">candidate_j</span><span class="p">,</span> <span class="n">log_p_candidate_j</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r_</span>
                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                        <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">)</span>
                        <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

        <span class="c1"># The target pdf is provided as a joint pdf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">candidate_j</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">candidate</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_j</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Compute log_pdf_target of candidate sample</span>
                <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

                <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># proposal is symmetric</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
                    <span class="n">log_prop_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span>
                    <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="n">log_prop_j</span><span class="p">(</span><span class="n">candidate_j</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">-</span> \
                                         <span class="n">log_prop_j</span><span class="p">(</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">candidate_j</span><span class="p">)</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>
                <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
                <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate_j</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r_</span>
                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                        <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                        <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">candidate</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div></div>

<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="Stretch"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.Stretch">[docs]</a><span class="k">class</span> <span class="nc">Stretch</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Affine-invariant sampler with Stretch moves, parallel implementation.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. J. Goodman and J. Weare, Ensemble samplers with affine invariance, Commun. Appl. Math. Comput. Sci.,vol.5,</span>
<span class="sd">       no. 1, pp. 6580, 2010.</span>
<span class="sd">    2. Daniel Foreman-Mackey, David W. Hogg, Dustin Lang, and Jonathan Goodman. &quot;emcee: The MCMC Hammer&quot;.</span>
<span class="sd">       Publications of the Astronomical Society of the Pacific, 125(925):306312,2013.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        Scale parameter. Default: 2.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Check nchains = ensemble size for the Stretch algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: For the Stretch algorithm, a seed must be provided with at least two samples.&#39;</span><span class="p">)</span>

        <span class="c1"># Check Stretch algorithm inputs: proposal_type and proposal_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input scale must be of type float.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="Stretch.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.Stretch.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for Stretch algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start the loop over nsamples - this code uses the parallel version of the stretch algorithm</span>
        <span class="n">all_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">all_inds</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,))</span>
        <span class="c1"># Separate the full ensemble into two sets, use one as a complementary ensemble to the other and vice-versa</span>
        <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">S1</span> <span class="o">=</span> <span class="p">(</span><span class="n">inds</span> <span class="o">==</span> <span class="n">split</span><span class="p">)</span>

            <span class="c1"># Get current and complementary sets</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_state</span><span class="p">[</span><span class="n">inds</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">split</span><span class="p">],</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">split</span><span class="p">]</span>  <span class="c1"># current and complementary sets respectively</span>
            <span class="n">Ns</span><span class="p">,</span> <span class="n">Nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c1"># Sample new state for S1 based on S0 and vice versa</span>
            <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">Ns</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">zz</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">unif_rvs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>  <span class="c1"># sample Z</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span>  <span class="c1"># compute log(Z ** (d - 1))</span>
            <span class="n">multi_rvs</span> <span class="o">=</span> <span class="n">Multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">Nc</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">Ns</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">rint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">multi_rvs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># sample X_{j} from complementary set</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">rint</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">rint</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>  <span class="c1"># new candidates</span>

            <span class="c1"># Compute new likelihood, can be done in parallel :)</span>
            <span class="n">logp_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

            <span class="c1"># Compute acceptance rate</span>
            <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">all_inds</span><span class="p">[</span><span class="n">S1</span><span class="p">]),</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">lpc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">u_rv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_inds</span><span class="p">[</span><span class="n">S1</span><span class="p">],</span> <span class="n">factors</span><span class="p">,</span> <span class="n">logp_candidates</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">unif_rvs</span><span class="p">):</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u_rv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f</span> <span class="o">+</span> <span class="n">lpc</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                    <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpc</span>
                    <span class="n">accept_vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div></div>


<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="DRAM"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DRAM">[docs]</a><span class="k">class</span> <span class="nc">DRAM</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Delayed Rejection Adaptive Metropolis algorithm</span>

<span class="sd">    In this algorithm, the proposal density is Gaussian and its covariance C is being updated from samples as</span>
<span class="sd">    C = sp * C_sample where C_sample is the sample covariance. Also, the delayed rejection scheme is applied, i.e,</span>
<span class="sd">    if a candidate is not accepted another one is generated from the proposal with covariance gamma_2 ** 2 * C.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. Heikki Haario, Marko Laine, Antonietta Mira, and Eero Saksman. &quot;DRAM: Efficient adaptive MCMC&quot;. Statistics</span>
<span class="sd">       and Computing, 16(4):339354, 2006</span>
<span class="sd">    2. R.C. Smith, &quot;Uncertainty Quantification - Theory, Implementation and Applications&quot;, CS&amp;E, 2014</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **initial_cov** (`ndarray`):</span>
<span class="sd">        Initial covariance for the gaussian proposal distribution. Default: I(dim)</span>

<span class="sd">    * **k0** (`int`):</span>
<span class="sd">        Rate at which covariance is being updated, i.e., every k0 iterations. Default: 100</span>

<span class="sd">    * **sp** (`float`):</span>
<span class="sd">        Scale parameter for covariance updating. Default: 2.38 ** 2 / dim</span>

<span class="sd">    * **gamma_2** (`float`):</span>
<span class="sd">        Scale parameter for delayed rejection. Default: 1 / 5</span>

<span class="sd">    * **save_cov** (`bool`):</span>
<span class="sd">        If True, updated covariance is saved in attribute `adaptive_covariance`. Default: False</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma_2</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">save_covariance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Check the initial covariance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">initial_covariance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                  <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input initial_covariance should be a 2D ndarray of shape (dimension, dimension)&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">=</span> <span class="mf">2.38</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_2</span> <span class="o">=</span> <span class="n">gamma_2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span> <span class="o">=</span> <span class="n">save_covariance</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;k0&#39;</span><span class="p">,</span> <span class="s1">&#39;sp&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma_2&#39;</span><span class="p">,</span> <span class="s1">&#39;save_covariance&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be of type &#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># initialize the sample mean and sample covariance that you need</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptive_covariance</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="DRAM.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DRAM.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for DRAM algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">MVNormal</span>
        <span class="n">mvp</span> <span class="o">=</span> <span class="n">MVNormal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># Sample candidate</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="n">current_cov</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">):</span>
            <span class="n">mvp</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="n">current_cov</span><span class="p">)</span>
            <span class="n">candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mvp</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>

        <span class="c1"># Compute log_pdf_target of candidate sample</span>
        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate (loop over nc chains)</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">inds_DR</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># indices of chains that will undergo delayed rejection</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">log_p_curr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">log_p_cand</span> <span class="o">-</span> <span class="n">log_p_curr</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>    <span class="c1"># enter delayed rejection</span>
                <span class="n">inds_DR</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>    <span class="c1"># these indices will enter the delayed rejection part</span>

        <span class="c1"># Delayed rejection</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># performed delayed rejection for some samples</span>
            <span class="n">current_states_DR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">candidates_DR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">candidate2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="c1"># Sample other candidates closer to the current one</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">):</span>
                <span class="n">current_states_DR</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">candidates_DR</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">mvp</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma_2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span>
                <span class="n">candidate2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_states_DR</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mvp</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
            <span class="c1"># Evaluate their log_target</span>
            <span class="n">log_p_candidate2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate2</span><span class="p">)</span>
            <span class="n">log_prop_cand_cand2</span> <span class="o">=</span> <span class="n">mvp</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidates_DR</span> <span class="o">-</span> <span class="n">candidate2</span><span class="p">)</span>
            <span class="n">log_prop_cand_curr</span> <span class="o">=</span> <span class="n">mvp</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidates_DR</span> <span class="o">-</span> <span class="n">current_states_DR</span><span class="p">)</span>
            <span class="c1"># Accept or reject</span>
            <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">cand2</span><span class="p">,</span> <span class="n">log_p_cand2</span><span class="p">,</span> <span class="n">J1</span><span class="p">,</span> <span class="n">J2</span><span class="p">,</span> <span class="n">u_rv</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">,</span> <span class="n">candidate2</span><span class="p">,</span> <span class="n">log_p_candidate2</span><span class="p">,</span>
                                                              <span class="n">log_prop_cand_cand2</span><span class="p">,</span> <span class="n">log_prop_cand_curr</span><span class="p">,</span> <span class="n">unif_rvs</span><span class="p">):</span>
                <span class="n">alpha_cand_cand2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_p_candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_p_cand2</span><span class="p">))</span>
                <span class="n">alpha_cand_curr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_p_candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]))</span>
                <span class="n">log_alpha2</span> <span class="o">=</span> <span class="n">log_p_cand2</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+</span> <span class="n">J1</span> <span class="o">-</span> <span class="n">J2</span> <span class="o">+</span> \
                             <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha_cand_cand2</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)))</span> <span class="o">-</span> \
                             <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha_cand_curr</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)))</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u_rv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">log_alpha2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand2</span>
                    <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand2</span>
                    <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Adaptive part: update the covariance</span>
        <span class="k">for</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="c1"># update covariance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_update_mean_covariance</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span><span class="p">,</span> <span class="n">new_sample</span><span class="o">=</span><span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:],</span> <span class="n">previous_mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span>
                <span class="n">previous_covariance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span> <span class="ow">and</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptive_covariance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_update_mean_covariance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">new_sample</span><span class="p">,</span> <span class="n">previous_mean</span><span class="p">,</span> <span class="n">previous_covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterative formula to compute a new sample mean and covariance based on previous ones and new sample.</span>

<span class="sd">        New covariance is computed only of previous_covariance is provided.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * n (int): Number of samples used to compute the new mean</span>
<span class="sd">        * new_sample (ndarray (dim, )): new sample</span>
<span class="sd">        * previous_mean (ndarray (dim, )): Previous sample mean, to be updated with new sample value</span>
<span class="sd">        * previous_covariance (ndarray (dim, dim)): Previous sample covariance, to be updated with new sample value</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * new_mean (ndarray (dim, )): Updated sample mean</span>
<span class="sd">        * new_covariance (ndarray (dim, dim)): Updated sample covariance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">previous_mean</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">new_sample</span>
        <span class="k">if</span> <span class="n">previous_covariance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_mean</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">new_sample</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sample</span> <span class="o">-</span> <span class="n">previous_mean</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">new_covariance</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">previous_covariance</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">delta_n</span><span class="p">,</span> <span class="n">delta_n</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_mean</span><span class="p">,</span> <span class="n">new_covariance</span></div>

<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="DREAM"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DREAM">[docs]</a><span class="k">class</span> <span class="nc">DREAM</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DiffeRential Evolution Adaptive Metropolis algorithm</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. J.A. Vrugt et al. &quot;Accelerating Markov chain Monte Carlo simulation by differential evolution with</span>
<span class="sd">       self-adaptive randomized subspace sampling&quot;. International Journal of Nonlinear Sciences and Numerical</span>
<span class="sd">       Simulation, 10(3):273290, 2009.[68]</span>
<span class="sd">    2. J.A. Vrugt. &quot;Markov chain Monte Carlo simulation using the DREAM software package: Theory, concepts, and</span>
<span class="sd">       MATLAB implementation&quot;. Environmental Modelling &amp; Software, 75:273316, 2016.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **delta** (`int`):</span>
<span class="sd">        Jump rate. Default: 3</span>

<span class="sd">    * **c** (`float`):</span>
<span class="sd">        Differential evolution parameter. Default: 0.1</span>

<span class="sd">    * **c_star** (`float`):</span>
<span class="sd">        Differential evolution parameter, should be small compared to width of target. Default: 1e-6</span>

<span class="sd">    * **n_CR** (`int`):</span>
<span class="sd">        Number of crossover probabilities. Default: 3</span>

<span class="sd">    * **p_g** (`float`):</span>
<span class="sd">        Prob(gamma=1). Default: 0.2</span>

<span class="sd">    * **adapt_CR** (`tuple`):</span>
<span class="sd">        (iter_max, rate) governs adaptation of crossover probabilities (adapts every rate iterations if iter&lt;iter_max).</span>
<span class="sd">        Default: (-1, 1), i.e., no adaptation</span>

<span class="sd">    * **check_chains** (`tuple`):</span>
<span class="sd">        (iter_max, rate) governs discarding of outlier chains (discard every rate iterations if iter&lt;iter_max).</span>
<span class="sd">        Default: (-1, 1), i.e., no check on outlier chains</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">delta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">c_star</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">n_CR</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">p_g</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">adapt_CR</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">check_chains</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Check nb of chains</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: For the DREAM algorithm, a seed must be provided with at least two samples.&#39;</span><span class="p">)</span>

        <span class="c1"># Check user-specific algorithms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_star</span> <span class="o">=</span> <span class="n">c_star</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">=</span> <span class="n">n_CR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_g</span> <span class="o">=</span> <span class="n">p_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adapt_CR</span> <span class="o">=</span> <span class="n">adapt_CR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span> <span class="o">=</span> <span class="n">check_chains</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c_star&#39;</span><span class="p">,</span> <span class="s1">&#39;n_CR&#39;</span><span class="p">,</span> <span class="s1">&#39;p_g&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be of type &#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;adapt_CR&#39;</span><span class="p">,</span> <span class="s1">&#39;check_chains&#39;</span><span class="p">]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Inputs &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be a tuple of 2 integers.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input save_log_pdf must be True in order to check outlier chains&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize a few other variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pCR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="DREAM.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DREAM.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for DREAM algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)])</span>
        <span class="n">CR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span>

        <span class="c1"># Dynamic part: evolution of chains</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
        <span class="n">lmda</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">std_x_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">multi_rvs</span> <span class="o">=</span> <span class="n">Multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">multi_rvs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">as_</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">draw</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="n">bs_</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">draw</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="n">multi_rvs</span> <span class="o">=</span> <span class="n">Multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pCR</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">multi_rvs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># id = np.random.choice(self.n_CR, size=(self.nchains, ), replace=True, p=self.pCR)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span>
                          <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_j</span> <span class="o">&lt;</span> <span class="n">CR</span><span class="p">[</span><span class="n">id_j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">z_j</span><span class="p">,</span> <span class="n">id_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">id</span><span class="p">)]</span>  <span class="c1"># subset A of selected dimensions</span>
        <span class="n">d_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">A_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">A_j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d_star</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span>
                <span class="n">d_star</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">gamma_d</span> <span class="o">=</span> <span class="mf">2.38</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_star</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Binomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_g</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">g</span><span class="p">[</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma_d</span><span class="p">[</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">norm_vars</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                                                 <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dX</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_star</span> <span class="o">*</span> <span class="n">norm_vars</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                           <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">lmda</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_state</span><span class="p">[</span><span class="n">as_</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[</span><span class="n">bs_</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">current_state</span> <span class="o">+</span> <span class="n">dX</span>

        <span class="c1"># Evaluate log likelihood of candidates</span>
        <span class="n">logp_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

        <span class="c1"># Accept or reject</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">lpc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_curr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">logp_candidates</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">lpc</span> <span class="o">-</span> <span class="n">log_p_curr</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpc</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dX</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dX</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">std_x_tmp</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Save the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>

        <span class="c1"># update selection cross prob</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">adapt_CR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">adapt_CR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pCR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pCR</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pCR</span><span class="p">)</span>
        <span class="c1"># check outlier chains (only if you have saved at least 100 values already)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_outlier_chains</span><span class="p">(</span><span class="n">replace_with_best</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>

<div class="viewcode-block" id="DREAM.check_outlier_chains"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DREAM.check_outlier_chains">[docs]</a>    <span class="k">def</span> <span class="nf">check_outlier_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replace_with_best</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check outlier chains in DREAM algorithm.</span>

<span class="sd">        This function checks for outlier chains as part of the DREAM algorithm, potentially replacing outlier chains</span>
<span class="sd">        (i.e. the samples and log_pdf_values) with &#39;good&#39; chains. The function does not have any returned output but it</span>
<span class="sd">        prints out the number of outlier chains.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **replace_with_best** (`bool`):</span>
<span class="sd">            Indicates whether to replace outlier chains with the best (most probable) chain. Default: False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input save_log_pdf must be True in order to check outlier chains&#39;</span><span class="p">)</span>
        <span class="n">start_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">avgs_logpdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">best_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">avgs_logpdf</span><span class="p">)</span>
        <span class="n">avg_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">avgs_logpdf</span><span class="p">)</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="n">ind3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.75</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="n">q1</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">avg_sorted</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">avg_sorted</span><span class="p">[</span><span class="n">ind3</span><span class="p">]</span>
        <span class="n">qr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span>

        <span class="n">outlier_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">avgs_logpdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">q1</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">qr</span><span class="p">:</span>
                <span class="n">outlier_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">replace_with_best</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">best_</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">best_</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Chain </span><span class="si">{}</span><span class="s1"> is an outlier chain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">outlier_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Detected </span><span class="si">{}</span><span class="s1"> outlier chains&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outlier_num</span><span class="p">))</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Importance Sampling</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="IS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS">[docs]</a><span class="k">class</span> <span class="nc">IS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample from a user-defined target density using importance sampling.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to generate - see ``run`` method. If not `None`, the `run` method is called when the object is</span>
<span class="sd">        created. Default is None.</span>

<span class="sd">    * **pdf_target** (callable):</span>
<span class="sd">        Callable that evaluates the pdf of the target distribution. Either log_pdf_target or pdf_target must be</span>
<span class="sd">        specified (the former is preferred).</span>

<span class="sd">    * **log_pdf_target** (callable)</span>
<span class="sd">        Callable that evaluates the log-pdf of the target distribution. Either log_pdf_target or pdf_target must be</span>
<span class="sd">        specified (the former is preferred).</span>

<span class="sd">    * **args_target** (`tuple`):</span>
<span class="sd">        Positional arguments of the target log_pdf / pdf callable.</span>

<span class="sd">    * **proposal** (``Distribution`` object):</span>
<span class="sd">        Proposal to sample from. This ``UQpy.Distributions`` object must have an rvs method and a log_pdf (or pdf)</span>
<span class="sd">        method.</span>

<span class="sd">    * **verbose** (`boolean`)</span>
<span class="sd">        Set ``verbose = True`` to print status messages to the terminal during execution.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        Set of samples, `ndarray` of shape (nsamples, dim)</span>

<span class="sd">    * **unnormalized_log_weights** (`ndarray`)</span>
<span class="sd">        Unnormalized log weights, i.e., log_w(x) = log_target(x) - log_proposal(x), `ndarray` of shape (nsamples, )</span>

<span class="sd">    * **weights** (`ndarray`):</span>
<span class="sd">        Importance weights, weighted so that they sum up to 1, `ndarray` of shape (nsamples, )</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Last Modified: 10/05/2020 by Audrey Olivier</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Initialize proposal: it should have an rvs and log pdf or pdf method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should be of type Distribution.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have an rvs method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have a log_pdf or pdf method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                                                <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span>

        <span class="c1"># Initialize target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">pdf</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args_target</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the samples and weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unweighted_samples</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Run IS if nsamples is provided</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="IS.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate and weight samples.</span>

<span class="sd">        This function samples from the proposal and appends samples to existing ones (if any). It then weights the</span>
<span class="sd">        samples as log_w_unnormalized) = log(target)-log(proposal).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`)</span>
<span class="sd">            Number of weighted samples to generate.</span>

<span class="sd">        * **Output/Returns:**</span>

<span class="sd">        This function has no returns, but it updates the output attributes `samples`, `unnormalized_log_weights` and</span>
<span class="sd">        `weights` of the ``IS`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Importance Sampling...&#39;</span><span class="p">)</span>
        <span class="c1"># Sample from proposal</span>
        <span class="n">new_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># Compute un-scaled weights of new samples</span>
        <span class="n">new_log_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_samples</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_samples</span><span class="p">)</span>

        <span class="c1"># Save samples and weights (append to existing if necessary)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">new_samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="n">new_log_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_samples</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">,</span> <span class="n">new_log_weights</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Take the exponential and normalize the weights</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">))</span>
        <span class="c1"># note: scaling with max avoids having NaN of Inf when taking the exp</span>
        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">sum_w</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Importance Sampling performed successfully&#39;</span><span class="p">)</span></div>

    <span class="c1"># def resample(self, method=&#39;multinomial&#39;, nsamples=None):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Resample to get a set of un-weighted samples that represent the target pdf.</span>
    <span class="c1">#</span>
    <span class="c1">#     Utility function that creates a set of un-weighted samples from a set of weighted samples. Can be useful for</span>
    <span class="c1">#     plotting for instance.</span>
    <span class="c1">#</span>
    <span class="c1">#     **Inputs:**</span>
    <span class="c1">#</span>
    <span class="c1">#     * **method** (`str`)</span>
    <span class="c1">#         Resampling method, as of V3 only multinomial resampling is supported. Default: &#39;multinomial&#39;.</span>
    <span class="c1">#     * **nsamples** (`int`)</span>
    <span class="c1">#         Number of un-weighted samples to generate. Default: None (same number of samples is generated as number of</span>
    <span class="c1">#         existing samples).</span>
    <span class="c1">#</span>
    <span class="c1">#     **Output/Returns:**</span>
    <span class="c1">#</span>
    <span class="c1">#     * (`ndarray`)</span>
    <span class="c1">#         Un-weighted samples that represent the target pdf, `ndarray` of shape (nsamples, dimension)</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     from .Utilities import resample</span>
    <span class="c1">#     return resample(self.samples, self.weights, method=method, size=nsamples)</span>

<div class="viewcode-block" id="IS.resample"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample to get a set of un-weighted samples that represent the target pdf.</span>

<span class="sd">        Utility function that creates a set of un-weighted samples from a set of weighted samples. Can be useful for</span>
<span class="sd">        plotting for instance.</span>

<span class="sd">        The ``resample`` method is not called automatically when instantiating the ``IS`` class or when invoking its</span>
<span class="sd">        ``run`` method.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **method** (`str`)</span>
<span class="sd">            Resampling method, as of V3 only multinomial resampling is supported. Default: &#39;multinomial&#39;.</span>
<span class="sd">        * **nsamples** (`int`)</span>
<span class="sd">            Number of un-weighted samples to generate. Default: None (sets `nsamples` equal to the number of</span>
<span class="sd">            existing samples).</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The method has no returns, but it creates the attribute following attribute of the ``IS`` object.</span>

<span class="sd">        * **unweighted_samples** (`ndarray`)</span>
<span class="sd">            Un-weighted samples that represent the target pdf, `ndarray` of shape (nsamples, dimension)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;multinomial&#39;</span><span class="p">:</span>
            <span class="n">multinomial_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">multinomial_run</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">idx</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multinomial_run</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unweighted_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: Current available method: multinomial&#39;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess the target pdf inputs.</span>

<span class="sd">        Utility function (static method), that transforms the log_pdf, pdf, args inputs into a function that evaluates</span>
<span class="sd">        log_pdf_target(x) for a given x.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * log_pdf ((list of) callables): Log of the target density function from which to draw random samples. Either</span>
<span class="sd">          pdf_target or log_pdf_target must be provided</span>
<span class="sd">        * pdf ((list of) callables): Target density function from which to draw random samples.</span>
<span class="sd">        * args (tuple): Positional arguments of the pdf target</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * evaluate_log_pdf (callable): Callable that computes the log of the target density function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log_pdf is provided</span>
        <span class="k">if</span> <span class="n">log_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target must be a callable&#39;</span><span class="p">)</span>
        <span class="c1"># pdf is provided</span>
        <span class="k">elif</span> <span class="n">pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: pdf_target must be a callable&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target or pdf_target should be provided.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evaluate_log_pdf</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../runmodel.html">RunModel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplemethods.html">SampleMethods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stochastic_process.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surrogates.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reliability.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dimension_reduction.html">Dimension reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, SURG, JHU.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>